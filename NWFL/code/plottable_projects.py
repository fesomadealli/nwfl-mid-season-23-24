# -*- coding: utf-8 -*-
"""plottable-projects.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18QNAoif_4dhmfdjV23V3S4b-dOC9Vb0b

## **MOUNT GDRIVE**
"""

from google.colab import drive
drive.mount('/content/drive')

"""

























## **IMPORTS AND LIBRARY INSTALLATIONS**"""

import matplotlib.font_manager as fm
import matplotlib as mpl
import re

# Register the Oswald font
fm.fontManager.addfont('/content/drive/MyDrive/NWFL/fonts/Oswald-Bold.ttf')
fm.fontManager.addfont('/content/drive/MyDrive/NWFL/fonts/Oswald-Light.ttf')
fm.fontManager.addfont('/content/drive/MyDrive/NWFL/fonts/Oswald-Regular.ttf')
fm.fontManager.addfont('/content/drive/MyDrive/NWFL/fonts/Anton-Regular.ttf')

# Specify the font family and size
font = {'family': 'Oswald',
        'size': 12}

# Update the default font settings
mpl.rc('font', **font)

pip install plottable

pip install  highlight_text

# from google.colab import drive
# drive.mount('/content/drive')

# Plottable Table Tool
from plottable import Table

# General Data Analytics Libraries
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

# Text Customization & Fancy Legend Library
import matplotlib.patheffects as path_effects
from matplotlib.patheffects import withStroke
import highlight_text
h_axs = highlight_text.ax_text
h_fig = highlight_text.fig_text

# Run Multiple Commands In Single Cell
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = "all"
# Show All Columns
pd.set_option('display.max_columns', None)

"""## **PLOT ELEMENTS**"""

df23_season = '2022/23'
df24_season = '2023/24'
author = '@fesomadealli'

# Font
b_font =  'Merriweather'
t_font = 'Fira Code'
b_fsize = 14
t_fsize = 16

# Colors for Dark Mode
facecolor = '#242526' #18191A is an alternative choice
ax_color = '#3A3B3C'
plot_color = '#E0CB8A'
off_white = '#FAF9F6'
alt_color = '#303233'

# Figure Paddings
pad_top = "\n\n"
pad_end = "\n\n"
hspace  = " "
vspace  = " "
newline = '\n'

"""## **LOAD NWFL DATASETS**"""

mid_2223 = pd.read_csv('/content/drive/MyDrive/NWFL/csv/NWFL_MID_SEASON_2022_23.csv')
mid_2324 = pd.read_csv('/content/drive/MyDrive/NWFL/csv/NWFL_MID_SEASON_2023_24.csv')

#mid_2324 = pd.read_excel('/content/NWFL_MID_SEASON_2023_24.xlsx')
#mid_2223 = pd.read_excel('/content/NWFL_MID_SEASON_2022_23.xlsx')

mid_2324.info()

"""## **SUMMARRY STATISTICS**

### **2022/23**
"""

mid_2223.describe()

mid_2223.info()

"""### **2023/24**"""

mid_2324.describe()

mid_2324.info()

"""## **FUNCTIONS**"""

# Extract goal_info
def extract_numbers(goal_string):
  """
  Returns a List of integers
  Targeted at Performing Goal Difference Analyses
  For extracting the time when the goals were scored by the teams
  It is expected that there are no null values so all null values are expected to have been handled
  """
  # Extract strings enclosed in () and remove non-numeric characters except commas and plus
  matches = re.findall(r'\(([^)]+)\)', goal_string)
  processed_matches = []
  for match in matches:
      numeric_part = re.sub(r'[^0-9\+\,]+', '', match)
      for sub_match in numeric_part.split(','):
        # replace 'a+b' with the sum of a and b
          if '+' in sub_match:
              a, b = sub_match.split('+')
              sub_match = str(int(a) + int(b))
          processed_matches.append(sub_match)
  return processed_matches

def goals_agg(df):
    # Counting Home Games Played Per Team
    home = df['Home Team'].value_counts().reset_index()
    # Renaming Columns
    home.rename(columns={'index': 'Home Team', 'Home Team': 'MP'}, inplace=True)

    # Counting Away Games Played Per Team
    away = df['Away Team'].value_counts().reset_index()
    # Renaming Columns
    away.rename(columns={'index': 'Away Team', 'Away Team': 'MP'}, inplace=True)

    # GroupBy Home
    hgoals_df = df.groupby('Home Team')['HTHG', 'HTAG', 'SHHG', 'SHAG', 'FTHG', 'FTAG'].sum().reset_index()
    # Renaming Columns
    hgoals_df.rename(columns={'HTHG': 'HTGF', 'HTAG': 'HTGA', 'SHHG': 'SHGF', 'SHAG': 'SHGA', 'FTHG': 'FTGF', 'FTAG': 'FTGA'}, inplace=True)
    # Calculate the Average Goals
    hgoals_mean = df.groupby('Home Team')['HTHG', 'HTAG', 'SHHG', 'SHAG', 'FTHG', 'FTAG'].mean().round(2).reset_index()
    hgoals_mean.rename(columns={'HTHG': 'HTGF_Avg', 'HTAG': 'HTGA_Avg', 'SHHG': 'SHGF_Avg', 'SHAG': 'SHGA_Avg', 'FTHG': 'FTGF_Avg', 'FTAG': 'FTGA_Avg'}, inplace=True)
    # Merge DataFrames on the common column
    hgoals = pd.merge(hgoals_df, hgoals_mean, on='Home Team')
    # Add Number of Games Played Per Team
    hgoals = pd.merge(hgoals, home, on='Home Team')
    # Reorder 'MP' Column By Insertion
    home_mp = hgoals['MP']
    hgoals = hgoals.drop(columns=['MP'])
    hgoals.insert(loc=1, column='MP', value=home_mp)

    #  GroupBy Away
    agoals_df = df.groupby('Away Team')['HTHG', 'HTAG', 'SHHG', 'SHAG', 'FTHG', 'FTAG'].sum().reset_index()
    # Renaming Column Headers
    agoals_df.rename(columns={'HTHG': 'HTGA', 'HTAG': 'HTGF', 'SHHG': 'SHGA', 'SHAG': 'SHGF', 'FTHG': 'FTGA', 'FTAG': 'FTGF'}, inplace=True)
    # Calculate the Average Goals
    agoals_mean = df.groupby('Away Team')['HTHG', 'HTAG', 'SHHG', 'SHAG', 'FTHG', 'FTAG'].mean().round(2).reset_index()
    agoals_mean.rename(columns={'HTHG': 'HTGA_Avg', 'HTAG': 'HTGF_Avg', 'SHHG': 'SHGA_Avg', 'SHAG': 'SHGF_Avg', 'FTHG': 'FTGA_Avg', 'FTAG': 'FTGF_Avg'}, inplace=True)
    # Merge DataFrames on the common column
    agoals = pd.merge(agoals_df, agoals_mean, on='Away Team')
    # Add Number of Games Played Per Team
    agoals = pd.merge(agoals, away, on='Away Team')
    # Reorder 'MP' Column By Insertion
    away_mp = agoals['MP']
    agoals = agoals.drop(columns=['MP'])
    agoals.insert(loc=1, column='MP', value=away_mp)

    list_of_teams = df['Home Team'].unique()
    for team in list_of_teams:
      team.strip()
    list_of_teams = sorted(set(list_of_teams))

    # Combined Goals Table
    gls_df = pd.DataFrame({
                    'Teams' : list_of_teams,
                       'MP' : hgoals.MP + agoals.MP,
                'HT_GlsFor' : hgoals.HTGF + agoals.HTGF,
            'HT_GlsAllowed' : hgoals.HTGA + agoals.HTGA,
                'SH_GlsFor' : hgoals.SHGF + agoals.SHGF,
            'SH_GlsAllowed' : hgoals.SHGA + agoals.SHGA,
                'FT_GlsFor' : hgoals.FTGF + agoals.FTGF,
            'FT_GlsAllowed' : hgoals.FTGA + agoals.FTGA,
    })

    # Goal Difference
    gls_df['HT_GlsDiff'] = gls_df.HT_GlsFor - gls_df.HT_GlsAllowed
    gls_df['SH_GlsDiff'] = gls_df.SH_GlsFor - gls_df.SH_GlsAllowed
    gls_df['FT_GlsDiff'] = gls_df.FT_GlsFor - gls_df.FT_GlsAllowed

    # Goal Averages
    gls_df['HT_GF_Avg'] = (gls_df.HT_GlsFor/gls_df.MP).round(2)
    gls_df['HT_GA_Avg'] = (gls_df.HT_GlsAllowed/gls_df.MP).round(2)
    gls_df['SH_GF_Avg'] = (gls_df.SH_GlsFor/gls_df.MP).round(2)
    gls_df['SH_GA_Avg'] = (gls_df.SH_GlsAllowed/gls_df.MP).round(2)
    gls_df['FT_GF_Avg'] = (gls_df.FT_GlsFor/gls_df.MP).round(2)
    gls_df['FT_GA_Avg'] = (gls_df.FT_GlsAllowed/gls_df.MP).round(2)

    # View Home Goals df
    return hgoals, agoals, gls_df

def show_all_cells(bool_cmd=True):
  """
  A function that displays all cells in dataframe. Please note, that this is not always advisable and isn't ideal for large datasets
  bool_cmd : (default=False) The boolean parameter that controls if the complete dataframe should be displayed or not
  """
  import pandas as pd
  if bool_cmd is True:
      # Set options to display all rows and columns
      pd.set_option('display.max_rows', None)
      pd.set_option('display.max_columns', None)
  else:
      # Reset options to default (if needed)
      pd.reset_option('display.max_rows')
      pd.reset_option('display.max_columns')

# Hide Spines
def hide_spines(axes, which_spine):
    spines = ['top', 'bottom', 'left', 'right']
    error_msg = (f"Invalid spine selection: '{which_spine}'. Please select from: {spines}")

    if which_spine != 'all':
        if type(which_spine) == list:
            for i in range(len(which_spine)):
                spine = which_spine[i]
                if spine in spines:
                    # Hide the enlisted spines
                    axes.spines[spine].set_visible(False)
                else:
                    return(error_msg)

        elif type(which_spine) == str:
            if which_spine in spines:
                axes.spines[which_spine].set_visible(False)
            else:
                return(error_msg)
    else:
        # Hide all spines
        for spine in range(len(spines)):
            axes.spines[spines[spine]].set_visible(False)

def calculate_standings(df, game_week=None, group=None):
    """
          df : DataFrame for calculating Standings
    game_week: The Match Week for which the Standings is to be returned
        games: (default='all') The partitioning of the games, whether home games, away games or the combined table
        group: (default=None) The group whose Standings we're interested in.
    """

    # Initialize dictionaries to store team stats
    team_stats = {'MP': {}, 'W': {}, 'D': {}, 'L': {}, 'GF': {}, 'GA': {}, 'GD': {}, 'PTS': {}, 'Group': {}}

    if game_week is not None:
      if type(game_week) is not int:
        return("You didn't enter a correct game week: expected int but got {}".format(type(game_week))), team_stats
      else:
        # Filter DataFrame for the specified match week
        filtered_df = df.loc[df['Game Week'] <= game_week]
    else:
        # Filter DataFrame for the specified match week
        filtered_df = df

    # Iterate through the filtered dataset
    for row_index, match in filtered_df.iterrows():
        home_team, away_team, hteam_gls, ateam_gls, result = match['Home Team'], match['Away Team'], match['FTHG'], match['FTAG'], match['FTR']
        hteam_grp = ateam_grp = match['Group']

        # Initialize team stats if not already in the dictionaries (This is a great assist by Chat-GPT)
        for stat in team_stats:
            team_stats[stat].setdefault(home_team, 0)
            team_stats[stat].setdefault(away_team, 0)

        # Update stats based on match result
        if result == 'H':
            team_stats['PTS'][home_team] += 3
            team_stats['W'][home_team] += 1
            team_stats['L'][away_team] += 1
        elif result == 'D':
            team_stats['PTS'][home_team] += 1
            team_stats['PTS'][away_team] += 1
            team_stats['D'][home_team] += 1
            team_stats['D'][away_team] += 1
        elif result == 'A':
            team_stats['PTS'][away_team] += 3
            team_stats['W'][away_team] += 1
            team_stats['L'][home_team] += 1

        # Update goals for and against
        team_stats['GF'][home_team] += hteam_gls
        team_stats['GA'][home_team] += ateam_gls
        team_stats['GF'][away_team] += ateam_gls
        team_stats['GA'][away_team] += hteam_gls

        # Update goal difference
        team_stats['GD'][home_team] = team_stats['GF'][home_team] - team_stats['GA'][home_team]
        team_stats['GD'][away_team] = team_stats['GF'][away_team] - team_stats['GA'][away_team]

        # Matches Played
        team_stats['MP'][home_team] += 1
        team_stats['MP'][away_team] += 1

        # Update Group Information
        team_stats['Group'][home_team] = hteam_grp
        team_stats['Group'][away_team] = ateam_grp

    # Create a DataFrame for standings
    standings_df = pd.DataFrame(team_stats)
    # Printing the dataframe
    standings_df.reset_index(level=0, inplace=True)

    # Ading & Reorder 'Teams' Column By Insertion
    teams = standings_df['index']
    standings_df = standings_df.drop(columns=['index'])
    standings_df.insert(loc=0, column='Teams', value=teams)

    # Sort standings by PTS in descending order
    standings_df = standings_df.rename(columns={'index': 'Team'})
    standings_df = standings_df.sort_values(by=['PTS', 'GD', 'GF', 'GA', 'Teams'], ascending=([False]*4 + [True])).reset_index()
    standings_df = standings_df.drop(['index'], axis=1)

    #  Return Dataframe per group based on user specificaton
    if group is not None and group.upper() in ['A','B']:
      standings_df = standings_df.loc[standings_df.Group == group.upper()]
      # Reset the index of the subset DataFrame
      standings_df = standings_df.reset_index(drop=True)
    else:
      return("Invalid Group Selection: The abridged 2023/24 NWFL season only had Groups A and B"), team_stats

    return standings_df, team_stats

def remove_whitespaces_from_df(df):
      # prepare the error message
      error_msg = "Expected DataFrame but got {}".format(str(type(df)).split("'")[1])
      # Writing the Main Function
      def main(df):
          """
          This function does the cleaning in itself
          df: (DataFrame Object) This is the Dataframe to be eventually cleaned
          """
          # Remove whitespaces from Column Names
          df.columns = [col.strip() for col in df.columns]
          # Remove Leading & Trailing Whitespaces from all rows using Vectorization
          df = df.apply(lambda x: x.str.strip() if x.dtype == "object" else x)
          return df

      # check function parameters
      if type(df) is list:
          # Initislize a List for holding the cleaned versions of the dfs
          cleaned_dfs = []
          # iterate over the dfs to be cleaned
          for dataframe in df:
              if type(dataframe) is pd.core.frame.DataFrame:
                  dataframe = main(dataframe)
                  cleaned_dfs.append(dataframe)
              else:
                  raise TypeError(error_msg)
          # Return list of cleaned dfs
          return cleaned_dfs

      # If cleaning just one df
      elif type(df) is pd.core.frame.DataFrame:
        main(df)
      else:
        raise TypeError(error_msg)
      # Return df
      return df

def league_pos_across_gw(df, gw, group):
    # Getting teams in their drawn groups
    teams = GrpA if group.upper() == 'A' else GrpB if group.upper() == 'B' else None

    # Create an empty DataFrame to store the standings for each match week
    standings_by_week = pd.DataFrame(index=range(1, gw+1))

    # Iterate through each team to calculate standings for each match week
    for team in teams:
        team_standings = []
        for week in range(1, gw+1):
            standings_df, _ = calculate_standings(df=df24, game_week=week, group=group)
            # display(standings_df.head())
            # Get the position of the team for the current match week
            position = standings_df[standings_df['Teams'] == team].index[0] + 1
            team_standings.append(position)
        # Add the team's standings for each match week to the DataFrame
        standings_by_week[team] = team_standings

    # Transposing the standings for better visual
    teams_pos_perwk = standings_by_week.T
    teams_pos_perwk = teams_pos_perwk.replace({1:"1st", 2:"2nd", 3:"3rd", 4:"4th",
                                               5:"5th", 6:"6th", 7:"7th", 8:"8th"})
    # Modifying column headers to reflect GWX where X is Game Week
    teams_pos_perwk.columns = [f'GW{str(col)}' for col in teams_pos_perwk.columns]
    # print(teams_pos_perwk)

    # Create a line plot
    plt.figure(figsize=(8, 6))
    plt.ylim(8.5,0.5)

    for team in teams:
        plt.plot(standings_by_week.index, standings_by_week[team], label=team)

    plt.title('Team Standings Over Match Weeks')
    plt.xlabel('Match Week')
    plt.ylabel('Position')
    # Place the legend to the right of the plot
    plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
    plt.grid(alpha=.25)
    plt.show();
    # Save figure
    plt.savefig("/content/drive/MyDrive/NWFL/plots/23_24_nwfl_league_pos_in_grp_{}_across_{}_gm_wks".format(group,str(gw)), dpi=100)
    #  Save the dataframe
    return teams_pos_perwk

def goalscorers_df(df):
    import re

    # Initialize the main dictionary
    main_dict = {}

    # Step 1: Collect unique seasons
    unique_seasons = df['Season'].unique()
    # print("Seasons: ", unique_seasons)

    # Step 2-8: Process HomeTeam Goals and AwayTeam Goals columns
    for season in unique_seasons:
        # Step 2: Initialize season dictionary
        season_dict = {}

        # Step 3-8: Process HomeTeam Goals and AwayTeam Goals columns
        for team_goals_column in ['HomeTeam Goals', 'AwayTeam Goals']:
            # Determine the team name column based on the current processing column
            team_name_column = 'Home Team' if team_goals_column == 'HomeTeam Goals' else 'Away Team'

            # Extract player and team information using the modified regex function
            def extract_info(row):  # row is a single row dataframe
                team_goals = row[team_goals_column]
                if pd.notna(team_goals):
                    # Remove non-alphanumeric characters and emojis
                    matches = re.sub(r'(?![\(\)\[\],\n])[^\w\s\n+]+', '', team_goals)
                    # print(matches)
                    # Split the string by newline character
                    goals = matches.split('\n')
                    # print(goals)
                    for goalscorer_info in goals:
                        matches = re.findall(r'([^\(]+)\s*\(([^)]+)\)', goalscorer_info)
                        # print(matches)
                        for match in matches:
                            player_name = match[0].strip()
                            goal_details = match[1].replace(" ", "")
                            # print(player_name, ":", goal_details,"\n")

                            # Step 4-8: Update the complex data structure
                            player_dict = season_dict.setdefault(player_name, {})
                            team_name = row[team_name_column]
                            team_dict = player_dict.setdefault(team_name, {})
                            date_str = str(row['Date']).split()[0] if pd.notna(row['Date']) else '00/00/0000'
                            date_dict = team_dict.setdefault(date_str, {})

                            # Step 5-8: Update values
                            date_dict['Team Faced'] = row['Away Team'] if team_goals_column == 'HomeTeam Goals' else row['Home Team']
                            date_dict['Goals Scored'] = len(goal_details.split(","))
                            date_dict['Goal Time'] = goal_details

            # Apply the extract_info function to the DataFrame
            df.apply(extract_info, axis=1)

        # Step 9: Append the season dictionary to the main dictionary
        main_dict[season] = season_dict

    # print(main_dict);

    # # Step 10: Convert the complex data structure into a DataFrame
    data = []
    for season, season_dict in main_dict.items():
        for player_name, player_dict in season_dict.items():
            for team_name, team_dict in player_dict.items():
                for date_str, date_dict in team_dict.items():
                    row = {'Season': season, 'Player Name': player_name, 'Team Name': team_name, 'Date': date_str}
                    row.update(date_dict);
                    data.append(row);

    # Create DataFrame
    result_df = pd.DataFrame(data);
    return result_df
    # Display the resulting DataFrame
    # print(result_df);

# Define a global _goals variable to collect a dataframe of goal scorers
# that is grouped by the number of goals they scored in a match
# (eg: lone goal[index 0], brace[index 1], hat-trick[index 2], haul[index 3]... etc)
# Note the index
global _goals
_goals = []

def melted_gls_df(df):
    """
    For optimal function and to reduce load on this function, endeavor to remove the rows where only a (one) goal was scored.
    Do this by subsetting the dataframe where one goal was scored and later on you may concatenate that dataframe with the one returned by this function.
    """
    # Get unique values in 'Goals Scored' column
    unique_goals = df['Goals Scored'].unique()
    melted_dfs = []

    # Create separate DataFrames for each unique value in 'Goals Scored'
    for goals in unique_goals:
        # Subset the original DataFrame based on 'Goals Scored'
        subset_df = df[df['Goals Scored'] == goals].copy()

        # Split 'Goal Time' column into multiple columns based on the number of goals
        subset_df[['goal_' + str(i) for i in range(1, goals + 1)]] = subset_df['Goal Time'].str.split(',', expand=True)

        # Melt the DataFrame to create a new row for each goal
        melted_df = pd.melt(subset_df, id_vars=['Season', 'Player Name', 'Team Name', 'Date', 'Team Faced', 'Goals Scored'],
                            value_vars=['goal_' + str(i) for i in range(1, goals + 1)], value_name='Goal Info')

        # Drop unnecessary columns
        melted_df = melted_df.drop(['variable'], axis=1).dropna()
        # Keeping track of all melted dfs
        melted_dfs.append(melted_df)

    # Updat our global _goals df
    _goals = melted_dfs
    # Concatenate all melted DataFrames vertically
    concatenated_df = pd.concat(melted_dfs, ignore_index=True)

    # Display
    concatenated_df['Goals Scored'] = 1
    return concatenated_df

# Function to check for own_goal
def check_own_goal(info):
    """
    To use this function, please use the applymap() method.
    """
    own_goal = "[og]"

    # Convert to lowercase and remove any fullstops
    info_lower = info.lower().replace('.', '')
    # print(info)
    if own_goal in info_lower:
        # print("Own goal found!")
        return int(True)
    else:
        return int(False)

# Function to check for own_goal and penalty
def check_penalty_goals(info):
    """
    To use this function, please use the applymap() method.
    """
    penalty = "[pen]"
    alt_penalty = "[pk]"

    # Convert to lowercase and remove any fullstops
    info_lower = info.lower().replace('.', '')

    if (penalty in info_lower) or (alt_penalty in info_lower):
        # print("Penalty found!")
        return int(True)
    else:
        return int(False)

def time_dist_of_goals(df, dist='goals_for'):
  """
  df : (DataFrame) dataframe to be used
  dist: (String) goals_for or goals_allowed  (default: goals_for)
  """
  import re
  # Extract minute information from Goal Info
  df['Minute'] = df['Goal Info'].str.extract(r'(\d+)').astype(int)
  # Create empty column
  df['group'] = np.nan
  # Assign values to categorize goals based on goal time
  for i, row in df.iterrows():
      if '45+' in row['Goal Info']:
          df.at[i,'group'] = '45+'
      elif '90+' in row['Goal Info']:
          df.at[i,'group'] = '90+'
      else:
          # print(f"Item {row['Goal Info']} at {i} is initially of type; ", type(row['Goal Info']))
          integer_value = int((re.findall(r'(\d+)', str(row['Goal Info'])))[0])
          # print(f"Item {row['Goal Info']} at {i} is now formatted as {integer_value} and of type; ", type(integer_value))
          if integer_value <= 15:
              df.at[i,'group'] = '0-15'
          elif 15 < integer_value <= 30:
              df.at[i,'group'] = '16-30'
          elif 30 < integer_value <= 45:
              df.at[i,'group'] = '31-45'
          elif 45 < integer_value <= 60:
              df.at[i,'group'] = '46-60'
          elif 60 < integer_value <= 75:
              df.at[i,'group'] = '61-75'
          elif 75 < integer_value <= 90:
              df.at[i,'group'] = '76-90'

  # Format the 'group' column as category
  df['group'] = df['group'].astype('category')
  # Drop the 'Goal Info' column
  df.drop('Goal Info', axis=1, inplace=True)

  if dist is "goals_for":
    col = "Team Name"
  else:
    col = 'Team Faced'

  # Create a new DataFrame 'new_df' with columns: 'Team' and categories from 'group'
  new_df = pd.DataFrame({'Team': df['{}'.format(col)]})
  # Get unique categories from 'group' column
  categories = df['group'].cat.categories
  # Sort the categories alphabetically
  categories = sorted(categories)

  # Add columns for each category in 'new_df'
  for category in categories:
      new_df[category] = 0
  # Count occurrences of each category for each team
  for i, row in df.iterrows():
      team = row['Team']
      category = row['group']
      new_df.at[i, category] = new_df.at[i, category] + 1

  # Convert all columns except 'Team' to integers
  new_df.iloc[:, 1:] = new_df.iloc[:, 1:].astype(int)
  # Perform groupby operation on 'Team' and sum the values across other columns
  grouped_df = new_df.groupby('Team').sum()
  # Reset the index
  grouped_df = grouped_df.reset_index()
  # Calculate sum across rows and create 'Sum' column
  grouped_df['Sum'] = grouped_df.iloc[:, 1:].sum(axis=1)
  # Insert 'Sum' column at index 1
  grouped_df.insert(1, 'Goals', grouped_df.pop('Sum'))

  # PLOT THE GOALS TABLE
  fig = plt.figure(figsize=(7,7), dpi=100)
  ax = plt.subplot()

  ncols = len(grouped_df.columns.to_list())
  nrows = grouped_df.shape[0]

  ax.set_xlim(0, ncols + 1)
  ax.set_ylim(0, nrows + .5)

  positions = [0.25, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5]

  # Create column headers
  column_headers = grouped_df.columns.to_list()

  # Add table's main text
  for i in range(nrows):
      for j, column in enumerate(column_headers):
          if j == 0:
              ha = 'left'
          else:
              ha = 'center'
          if column == 'Goals':
            weight = 'bold'
          else:
            weight = 'normal'
          ax.annotate(
              xy=(positions[j], nrows-(0.5*(i + 0.5))),
              text=grouped_df[column].iloc[i],
              ha=ha,
              va='center',
              weight=weight
          )

  # Add column names
  x = grouped_df.columns.to_list()
  # Removing 'Teams' label from the column names
  x[0] = ""
  column_names = x
  for index, c in enumerate(column_names):
          if index == 0:
              ha = 'left'
          else:
              ha = 'center'
          ax.annotate(
              xy=(positions[index], nrows + 0.15),
              text=column_names[index],
              ha=ha,
              va='bottom',
              weight='bold'
          )

  # Add dividing lines
  # Top Line
  ax.plot([ax.get_xlim()[0], ax.get_xlim()[1]], [nrows, nrows], lw=1.5, color='black', marker='', zorder=4)
  # Base Line
  ax.plot([ax.get_xlim()[0], ax.get_xlim()[1]], [0, 0], lw=1.5, color='black', marker='', zorder=4)
  # Line Between Table Items
  for x in range(1, nrows):
      ax.plot([ax.get_xlim()[0], ax.get_xlim()[1]], [nrows-(x*.5), nrows-(x*.5)], lw=1.25, color='gray', ls=':', zorder=3 , marker='')

  # ax.set_axis_off()
  plt.show();
  return grouped_df

"""## **DATA CLEANING AND PREPROCESSING**"""

# Replace The Dataframes with the cleaned one
df_ws = remove_whitespaces_from_df(df=[mid_2223, mid_2324]);
mid_2223 = df_ws[0]
mid_2324 = df_ws[1]

mid_2324.columns.to_list()
mid_2324['Home Team'].unique()
len(mid_2324['Home Team'].unique())

# Renaming Nassarawa to Nasarawa
mid_2324.replace('Nassarawa Amazons', 'Nasarawa Amazons', inplace=True)
mid_2223.replace('Nassarawa Amazons', 'Nasarawa Amazons', inplace=True)

# Copy Dataframes
df23=mid_2223.copy()
df24=mid_2324.copy()

print("22/23 SEASON DATA:\n{}\n{}\n\n 23/24 SEASON DATA:\n{}\n{}".format(df23.shape, df23.columns, df24.shape, df24.columns))

"""### **NWFL 2022/23 MID-SEASON**"""

# Reduce Range of Data
df23 = df23.drop(df23.loc[:,'HomeTeam XI':'Penalties'].columns, axis = 1)

# View Dataframe
df23.head(3)

# Second Half Home Goals
df23['SHHG'] = df23.FTHG - df23.HTHG
df23['SHAG'] = df23.FTAG - df23.HTAG

#  View Dataframe
df23.sample(5)

# Reorder 'SHAG' Column By Insertion
shag = df23['SHAG']
df23 = df23.drop(columns=['SHAG'])
df23.insert(loc=11, column='SHAG', value=shag)

# Reorder 'SHHG' Column By Insertion
shhg = df23['SHHG']
df23 = df23.drop(columns=['SHHG'])
df23.insert(loc=12, column='SHHG', value=shhg)

#  View Dataframe
df23.head(2)

df23.info()

#  Converting Column Type(s)
df23['Notes'] = df23['Notes'].astype('str')
# df23[['HTHG', 'HTAG', 'SHHG', 'SHAG']] = df23[['HTHG', 'HTAG', 'SHHG', 'SHAG']].astype('int64')       # won't work without removing null values

"""### **NWFL 2023/24 MID-SEASON**"""

# Reduce Range of Data
df24 = df24.drop(df24.loc[:,'HomeTeam XI':'Penalties'].columns, axis = 1)
# View Dataframe
df24.head(2)

# Second Half Home Goals
df24['SHHG'] = df24.FTHG - df24.HTHG
df24['SHAG'] = df24.FTAG - df24.HTAG
#  View Dataframe
df24.head(2)

# Reorder 'SHAG' Column By Insertion
shag = df24['SHAG']
df24 = df24.drop(columns=['SHAG'])
df24.insert(loc=11, column='SHAG', value=shag)

# Reorder 'SHHG' Column By Insertion
shhg = df24['SHHG']
df24 = df24.drop(columns=['SHHG'])
df24.insert(loc=12, column='SHHG', value=shhg)

# View Dataframe
df24.head(3)

"""## **DATA TORCHLIGHTING**

### **2023/24 NWFL TEAMS**
"""

GrpA = sorted(list(df24.loc[df24['Group'] == 'A']['Home Team'].unique()))
GrpA

GrpB = sorted(list(df24.loc[df24['Group'] == 'B']['Home Team'].unique()))
GrpB

# Combined list of teams
list_of_teams = sorted(GrpA + GrpB)

# Display the result
type(list_of_teams)
print(list_of_teams)
len(list_of_teams)

"""### **LEAGUE TABLE TREND**"""

# Mid Season Standings
nwfl24_grpA_gw7, _dict = calculate_standings(df=df24, game_week=7, group='a')
nwfl24_grpA_gw7

league_pos_across_gw(df=df24, gw=7, group='a')

league_pos_across_gw(df=df24, gw=7, group='b')

"""####**2022/23 TRE

### **COMPARING MID-SEASON SUMMARIES (2022/23 VERSUS 2023/24 SEASON)**
"""

# Current Season (2023/24)
print("2023/24 SEASON\n")
df24.describe().round(2)

# Previous Season (2023/24)
print("\n2022/23 SEASON\n")
df23.describe().round(2)

"""## **GOALS ANALYSES**

### **DATA AGGREGATION (GOALS)**

####**GOALS IN GAMES**
"""

gls_gms24 = df24.loc[(df24['FTHG'] != 0) | (df24['FTAG'] != 0)]
print("{} Mid Season: Goals were scored on {} different match days".format(df24_season, len(gls_gms24)))

gls_gms23 = df23.loc[(df23['FTHG'] != 0) | (df23['FTAG'] != 0)]
print("{} Mid Season: Goals were scored on {} different match days".format(df23_season, len(gls_gms23)))

"""####**GOALLESS DRAWS**"""

no_gls_in_gms24 = df24.loc[(df24['FTHG'] == 0) & (df24['FTAG'] == 0)]
print("There were {} goalless draws in {} Mid Season".format(len(no_gls_in_gms24), df24_season))

no_gls_in_gms23 = df23.loc[(df23['FTHG'] == 0) & (df23['FTAG'] == 0)]
print("There were {} goalless draws in {} Mid Season".format(len(no_gls_in_gms23), df23_season))

"""#### **2022/23 SEASON GOALS AGG**"""

hgoals23, agoals23, comb23 = goals_agg(df23)

hgoals23

agoals23

comb23

"""#### **2023/24 SEASON GOALS AGG**"""

hgoals, agoals, gls_df = goals_agg(df24)

# View Home Goals df
hgoals

# View Away Games Goals Table
agoals

# Combined Goals Table
gls_df

"""### **TIME DISTRIBUTION OF GOALS SCORED/CONCEDED**"""

show_all_cells()
goals24 = goalscorers_df(df24)
goals24
# !cp <output-file-name> /content/drive/MyDrive/<destination-folder-name>
# goals24.to_csv(r'/content/drive/MyDrive/NWFL/csv/2023_24_NWFL_MID_SEASON_GOALS.csv')

show_all_cells(False)
goals24['Goals Scored'].sum()
total_goals24 = df24.FTHG.sum() + df24.FTAG.sum()
print(goals24['Goals Scored'].sum() == total_goals24)

goals24['Goals Scored'].value_counts()

# Flatten Goals Dataframe
goals24_mod = melted_gls_df(goals24)
# Check Goal Description
goals24_mod['own_goal'] = goals24_mod[['Goal Info']].applymap(check_own_goal)
goals24_mod['penalty'] = goals24_mod[['Goal Info']].applymap(check_penalty_goals)
# Clean the 'Player Name' column
for i, name in enumerate(goals24_mod['Player Name']):
  goals24_mod['Player Name'][i] = re.sub(r'[^A-Za-z\s]+', '', goals24_mod['Player Name'][i])


# Show all cells
show_all_cells()
# View Dataframe
goals24_mod

# Plot Goals Per Match Time Interval
show_all_cells(False)
time_dist_gls = goals24_mod[['Team Name',   'Team Faced', 'Goal Info']]
time_dist_gls

def time_dist_of_goals(df=time_dist_gls, dist="goals_for"):

    import re

    # Extract minute information from Goal Info
    df['Minute'] = df['Goal Info'].str.extract(r'(\d+)').astype(int)
    # Create empty column
    df['group'] = np.nan
    # Assign values to categorize goals based on goal time
    for i, row in df.iterrows():
        if '45+' in row['Goal Info']:
            df.at[i,'group'] = '45+'
        elif '90+' in row['Goal Info']:
            df.at[i,'group'] = '90+'
        else:
            integer_value = int((re.findall(r'(\d+)', str(row['Goal Info'])))[0])
            if integer_value <= 15:
                df.at[i,'group'] = '0-15'
            elif 15 < integer_value <= 30:
                df.at[i,'group'] = '16-30'
            elif 30 < integer_value <= 45:
                df.at[i,'group'] = '31-45'
            elif 45 < integer_value <= 60:
                df.at[i,'group'] = '46-60'
            elif 60 < integer_value <= 75:
                df.at[i,'group'] = '61-75'
            elif 75 < integer_value <= 90:
                df.at[i,'group'] = '76-90'
            elif 90 < integer_value:
                df.at[i,'group'] = '90+'

    # Format the 'group' column as category
    df['group'] = df['group'].astype('category')
    # Drop the 'Goal Info' column
    df.drop('Goal Info', axis=1)#, inplace=True)

    # Deciding columns to be used in case we want to show when teams are conceding
    if dist == "goals_for":
      col = "Team Name"
    elif dist == "goals_allowed":
      col = 'Team Faced'

    # Create a new DataFrame 'new_df' with columns: 'Team' and categories from 'group'
    new_df = pd.DataFrame({'Team': df['{}'.format(col)]})
    # Get unique categories from 'group' column
    categories = df['group'].cat.categories
    # Sort the categories alphabetically
    categories = sorted(categories)

    # Add columns for each category in 'new_df'
    for category in categories:
        new_df[category] = 0

    # Count occurrences of each category for each team
    for i, row in df.iterrows():
        team = row[f'{col}']
        category = row['group']
        new_df.at[i, category] = new_df.at[i, category] + 1
    # Convert all columns except 'Team' to integers
    new_df.iloc[:, 1:] = new_df.iloc[:, 1:].astype(int)

    # Perform groupby operation on 'Team' and sum the values across other columns
    grouped_df = new_df.groupby('Team').sum()
    # Reset the index
    grouped_df = grouped_df.reset_index()
    # Calculate sum across rows and create 'Sum' column
    grouped_df['Sum'] = grouped_df.iloc[:, 1:].sum(axis=1)
    # Insert 'Sum' column at index 1
    grouped_df.insert(1, 'Goals', grouped_df.pop('Sum'))


    # MAKING THE PLOT
    fig = plt.figure(figsize=(10,10), dpi=100)
    ax = plt.subplot()

    ncols = len(grouped_df.columns.to_list())
    nrows = grouped_df.shape[0]

    ax.set_xlim(-1, ncols + 15)
    ax.set_ylim(-1, nrows + .5)

    ax.set_axis_off()

    # column positions
    gls_col_pos = 7.00
    x_pos = gls_col_pos + 1.75
    positions = [0.25, gls_col_pos, x_pos+(1*1.75), x_pos+(2*1.75), x_pos+(3*1.75), x_pos+(4*1.75),
                x_pos+(5*1.75), x_pos+(6*1.75), x_pos+(7*1.75), x_pos+(8*1.75)]

    # Create column headers
    column_headers = grouped_df.columns.to_list()

    # Add table's main text
    for i in range(nrows):
        for j, column in enumerate(column_headers):
            if j == 0:
                ha = 'left'
                j_pos = positions[j]+0.5
            else:
                j_pos = positions[j]
                ha = 'center'
            if column == 'Goals':
              weight = 'normal'
              color = "black"
            else:
              weight = 'normal'
            if str(grouped_df[column].iloc[i]) == "0":
              color = "gray"
            else:
              color = "blue"
            if str(grouped_df[column].iloc[i]) in list_of_teams:
              color = 'black'
              size = 15

            ax.annotate(
                xy=(j_pos, nrows-(i + 0.75)),
                text=grouped_df[column].iloc[i],
                ha=ha,
                va='center',
                weight=weight,
                color=color
            )

    # Add column names
    x = grouped_df.columns.to_list()
    # Removing 'Teams' label from the column names
    x[0] = ""
    column_names = x
    for index, c in enumerate(column_names):
            if index == 0:
                ha = 'left'
            else:
                ha = 'center'
            ax.annotate(
                xy=(positions[index], nrows+0.5),
                text=column_names[index],
                ha=ha,
                va='bottom',
                weight='normal'
            )

    # Add dividing lines
    # Top Line
    ax.plot([ax.get_xlim()[0], ax.get_xlim()[1]], [nrows+0.15, nrows+0.15], lw=1.5, color='grey', marker='', zorder=4)
    # Base Line
    ax.plot([ax.get_xlim()[0], ax.get_xlim()[1]], [-0.5, -0.5], lw=1.5, color='grey', marker='', zorder=4)
    # Line Between Table Items
    for x in range(1, nrows):
        ax.plot([ax.get_xlim()[0], ax.get_xlim()[1]], [x-.25, x-.25], lw=1.25, color='gray', ls=':', zorder=3 , marker='')


    import matplotlib.image as mpimg
    for index, team in enumerate(grouped_df['Team']):
        img = mpimg.imread("/content/drive/MyDrive/NWFL/team-assets_2023_24/{}.png".format(team.replace(" ", "-").lower()))
        # Specify the extent (xmin, xmax, ymin, ymax) for the inset image in data coordinates
        image_size = [1, 2, 1, 2]
        # Add an inset axes to the main plot
        ax_inset = fig.add_axes([0.13, 0.81 - (index*0.044), 0.03, 0.03])
        # Add the image to the inset axes
        ax_inset.imshow(img, extent=image_size, aspect='auto')  # 'auto' maintains the aspect ratio of the image
        ax_inset.set_axis_off()

    from matplotlib.patheffects import withStroke
    # Top Padding
    pad_top = fig.text(0.35,1.05, s=hspace)
    # Name Text
    name_text = fig.text(0.15,0.1, s=author, fontweight="regular", color="grey")
    # Minutes Breakdown Line
    min_line = fig.text(0.45,0.92, s="_"*40, color='black',
                      font="Oswald", fontsize=16, fontweight="light")

    if dist == "goals_for":
      # Minutes Breakdown Label
        min_text = fig.text(0.55,0.93, s="Minute Breakdown of Goals Scored", color='black',
                          font="Oswald", fontsize=14, fontweight="light")
        # Plot Title
        figtext = fig.text(0.25,1.00, s="WHEN ARE THE TEAMS SCORING ?", color='white',
                          font="Anton", fontsize=28, fontweight="bold")
    elif dist == "goals_allowed":
      # Minutes Breakdown Label
        min_text = fig.text(0.53,0.93, s="Minute Breakdown of Goals Conceded", color='black',
                          font="Oswald", fontsize=14, fontweight="light")
        # Plot Title
        figtext = fig.text(0.25,1.00, s="WHEN ARE THE TEAMS CONCEDING ?", color='white',
                          font="Anton", fontsize=28, fontweight="bold")

    # Set patheffects
    grey_patheffects = [withStroke(foreground="grey", linewidth=3.5)]
    figtext.set_path_effects(grey_patheffects)
    black_patheffects = [withStroke(foreground="black", linewidth=0.08)]
    min_text.set_path_effects(black_patheffects)


    # Add NWFL Logo
    logo = mpimg.imread("/content/drive/MyDrive/NWFL/team-assets_2023_24/nwfl-logo.png")
    # Specify the extent (xmin, xmax, ymin, ymax) for the inset image in data coordinates
    image_size = [1, 2, 1, 2]
    # Add an inset axes to the main plot
    ax_inset = fig.add_axes([0.12, 0.82, 0.15, 0.15])
    # Add the image to the inset axes
    ax_inset.imshow(logo, extent=image_size, aspect='auto')  # 'auto' maintains the aspect ratio of the image
    ax_inset.set_axis_off()

    # Save Fig
    if dist == "goals_for":
      plt.savefig("/content/drive/MyDrive/NWFL/plots/when-are-the-teams-scoring_23_24_mid_nwfl.png", dpi=200)
    elif dist == "goals_allowed":
      plt.savefig("/content/drive/MyDrive/NWFL/plots/when-are-the-teams-conceding_23_24_mid_nwfl.png", dpi=200)
    plt.show();

time_dist_of_goals(dist="goals_for")

time_dist_of_goals(dist="goals_allowed")

"""### **GOALS AVERAGES**

#### **2023/24 GOALS AVERAGES**

#####**WRANGLE ACT**
"""

df24.Group.value_counts()
GroupA_df = df24.loc[df24["Group"]=="A"].reset_index()
GroupB_df = df24.loc[df24["Group"]=="B"].reset_index()

GroupA_df.drop("index", axis=1, inplace=True)
GroupA_df

GroupB_df.drop("index", axis=1, inplace=True)
GroupB_df

gls_df

total_goals = gls_df.FT_GlsFor.sum()
print("Total Number of Goals Recorded in NWFL Midway 2023/24: ", total_goals)

# 2023/24 League Average (Goals)
LAvg_Gls = (((hgoals.FTGF.sum()) + (agoals.FTGF.sum()))/len(df24)).round(2)
print("The League Average for Goals Scored:", LAvg_Gls)

# Group A Average (Goals)
GrpA_AvgGls = (GroupA_df.FTHG.sum()/len(GroupA_df)).round(2)
print("The Group A Average for Goals Scored:", GrpA_AvgGls)
# Group B Average (Goals)
GrpB_AvgGls = (GroupB_df.FTHG.sum()/len(GroupB_df)).round(2)
print("The Group B Average for Goals Scored:", GrpB_AvgGls)

print('Total Goals By Home Teams: ', hgoals.FTGF.sum())
print('Total Goals By Away Teams: ', agoals.FTGF.sum())
print("Total Number of Goals Recorded in NWFL Midway 2023/24: ", total_goals)
print('Total Games Played: ',len(df24))
print("The League Average for Goals:", LAvg_Gls)

print('Total Goals In Group A: ', GroupA_df.FTHG.sum() + GroupA_df.FTAG.sum())
print('Total Goals In Group B: ', GroupB_df.FTHG.sum() + GroupB_df.FTAG.sum())
print('Total Games Played Per Group: ',len(GroupA_df))

"""#####**PLOT VIZ**"""

# Data
items = list_of_teams

x_values = gls_df['FT_GA_Avg']
y_values = gls_df['FT_GF_Avg']

# Create a figure and axes with dark background
fig, ax = plt.subplots(figsize=(8, 6))
fig.patch.set_facecolor('#1E1E1E')  # Dark background color

# Scatter plot
scatter = ax.scatter(x_values, y_values, color='#42C5F4', edgecolor='grey',
                     alpha=0.7, zorder=1)

# Customize the scatter plot
ax.set_xlim(0.0, 3.0)
ax.set_ylim(0.0, 3.0)
ax.set_facecolor('#1E1E1E')  # Dark background color
# Change the color of ticks to red
ax.tick_params(axis='both', colors='grey')
hide_spines(axes=ax, which_spine='all')

# Add text above each scatter point with a white outline
for i, item in enumerate(items):
    ax.text(x_values[i], y_values[i] + 0.1, item,
            ha='center', va='center', color='white', zorder=0,
            fontsize=8, path_effects=[withStroke(linewidth=1.5, foreground='black')])

# Showing League Average
plt.axvline(x=2.09, linestyle='--', color='orange', alpha=.7)
plt.axhline(y=2.09, linestyle='--', color='orange', alpha=.7)
# Add arrow and text at the point of intersection
arrow_properties = dict(facecolor='white', edgecolor='grey', arrowstyle='->')
ax.annotate('({}) LAvg'.format(LAvg_Gls),
            xy=(2.09, 2.09), xycoords='data',
            xytext=(2.5, 2.5), textcoords='data',
            arrowprops=arrow_properties,
            fontsize=10, color='grey',
            path_effects=[withStroke(linewidth=1.5, foreground='#1E1E1E')])
# Showing Group A Average
plt.axvline(x=1.18, linestyle='--', color='grey', alpha=.4)
plt.axhline(y=1.18, linestyle='--', color='grey', alpha=.4)
ax.annotate('({}) Group A'.format(GrpA_AvgGls),
            xy=(1.18, 1.18), xycoords='data',
            xytext=(1.68, 1.38), textcoords='data',
            arrowprops=arrow_properties,
            fontsize=10, color='grey',
            path_effects=[withStroke(linewidth=1.5, foreground='#1E1E1E')])
# Showing Group B Average
plt.axvline(x=1.79, linestyle='--', color='grey', alpha=.4)
plt.axhline(y=1.79, linestyle='--', color='grey', alpha=.4)
ax.annotate('({}) Group B'.format(GrpB_AvgGls),
            xy=(1.79, 1.79), xycoords='data',
            xytext=(2.15, 1.98), textcoords='data',
            arrowprops=arrow_properties,
            fontsize=10, color='grey',
            path_effects=[withStroke(linewidth=1.5, foreground='#1E1E1E')])

# Set axis labels
ax.set_xlabel('Goals Allowed Average', color='grey')
ax.set_ylabel('Goals For Average', color='grey')

# Set title
ax.set_title('Mid Season Goals Averages (2023/24)'.upper(), color='grey')
# ax.text(x=1.5,y=-.5,s='LAvg = League Average', color='grey', ha='center',va='center')
# ax.text(x=1.5,y=-.75,s='{}'.format(author), color=plot_color, ha='center',va='center')
# Save Fig
plt.savefig("/content/drive/MyDrive/NWFL/plots/goals_avg_23_24_mid_nwfl.png", dpi=200)
# Show the plot
plt.show();

"""#### **2022/23 GOALS AVERAGES**

#####**WRANGLE ACT**
"""

teams_2223 = sorted(list(df23.loc[df23['Group'] == 'A']['Home Team'].unique())) + sorted(list(df23.loc[df23['Group'] == 'B']['Home Team'].unique()))
teams_2223

total_goals23 = comb23.FT_GlsFor.sum()
print("Total Number of Goals Recorded in NWFL Midway 2022/23: ", total_goals23)

df23.Group.value_counts()

# 2022/23 League Average (Goals)
LAvg_Gls23 = ((df23.FTHG.sum())/len(df23)).round(2)
print("The League Average for Goals Scored:", LAvg_Gls23)

# Group dfs
GroupA_df23 = df23.loc[df23["Group"]=="A"].reset_index()
GroupB_df23 = df23.loc[df23["Group"]=="B"].reset_index()

# Group A Average (Goals)
GrpA_AvgGls23 = (GroupA_df23.FTHG.sum()/len(GroupA_df)).round(2)
print("The Group A Average for Goals Scored:", GrpA_AvgGls23)
# Group B Average (Goals)
GrpB_AvgGls23 = (GroupB_df23.FTHG.sum()/len(GroupB_df)).round(2)
print("The Group B Average for Goals Scored:", GrpB_AvgGls23)

print('Total Goals In Group A: ', GroupA_df23.FTHG.sum()+GroupA_df23.FTAG.sum())
print('Total Goals In Group B: ', GroupB_df23.FTHG.sum()+GroupB_df23.FTAG.sum())
print('Total Games Played Per Group: ',len(GroupA_df23))

"""#####**PLOT VIZ**"""

# Data
items = teams_2223

season ="2022/23"
lavg = LAvg_Gls23
grpa_avg = GrpA_AvgGls23
grpb_avg = GrpB_AvgGls23

x_values = comb23['FT_GF_Avg']
y_values = comb23['FT_GA_Avg']
# x_values = comb23['FT_GA_Avg']
# y_values = comb23['FT_GF_Avg']

# Create a figure and axes with dark background
fig, ax = plt.subplots(figsize=(8, 6))
fig.patch.set_facecolor('#1E1E1E')  # Dark background color

# Scatter plot
scatter = ax.scatter(x_values, y_values, color='#42C5F4', edgecolor='grey',
                     alpha=0.7, zorder=1)

# Customize the scatter plot
ax.set_xlim(0.0, 3.0)
ax.set_ylim(0.0, 3.0)
ax.set_facecolor('#1E1E1E')  # Dark background color
# Change the color of ticks to red
ax.tick_params(axis='both', colors='grey')
hide_spines(axes=ax, which_spine='all')

# Add text above each scatter point with a white outline
for i, item in enumerate(items):
    ax.text(x_values[i], y_values[i] + 0.1, item,
            ha='center', va='center', color='white', zorder=0,
            fontsize=8, path_effects=[withStroke(linewidth=1.5, foreground='black')])

# Showing League Average
plt.axvline(x=lavg, linestyle='--', color='orange', alpha=.7)
plt.axhline(y=lavg, linestyle='--', color='orange', alpha=.7)
# Add arrow and text at the point of intersection
arrow_properties = dict(facecolor='white', edgecolor='grey', arrowstyle='->')
ax.annotate('({}) LAvg'.format(lavg),
            xy=(lavg, lavg), xycoords='data',
            xytext=(2.5, 2.5), textcoords='data',
            arrowprops=arrow_properties,
            fontsize=10, color='grey',
            path_effects=[withStroke(linewidth=1.5, foreground='#1E1E1E')])
# Showing Group A Average
plt.axvline(x=grpa_avg, linestyle='--', color='grey', alpha=.4)
plt.axhline(y=grpa_avg, linestyle='--', color='grey', alpha=.4)
ax.annotate('({}) Group A'.format(grpa_avg),
            xy=(grpa_avg, grpa_avg), xycoords='data',
            xytext=(1.68, 1.38), textcoords='data',
            arrowprops=arrow_properties,
            fontsize=10, color='grey',
            path_effects=[withStroke(linewidth=1.5, foreground='#1E1E1E')])
# Showing Group B Average
plt.axvline(x=grpb_avg, linestyle='--', color='grey', alpha=.4)
plt.axhline(y=grpb_avg, linestyle='--', color='grey', alpha=.4)
ax.annotate('({}) Group B'.format(grpb_avg),
            xy=(grpb_avg, grpb_avg), xycoords='data',
            xytext=(2.15, 1.98), textcoords='data',
            arrowprops=arrow_properties,
            fontsize=10, color='grey',
            path_effects=[withStroke(linewidth=1.5, foreground='#1E1E1E')])

# Set axis labels
# ax.set_xlabel('Goals Allowed Average', color='grey')
# ax.set_ylabel('Goals For Average', color='grey')

ax.set_ylabel('Goals Allowed Average', color='grey')
ax.set_xlabel('Goals For Average', color='grey')

# Set title
ax.set_title(f'Mid Season Goals Averages {(season)}'.upper(), color='grey')
# Save Fig
plt.savefig("/content/drive/MyDrive/NWFL/plots/goals_avg_22_23_mid_nwfl.png", dpi=200)
# Show the plot
plt.show();

"""### **OWN GOALS**"""

own_goals = goals24_mod.loc[goals24_mod["own_goal"]!=0]
own_goals

"""### **PENALTY GOALS**"""

pen_goals = goals24_mod.loc[goals24_mod["penalty"]!=0]
pen_goals

"""### **NUMBER OF GOALSCORERS PER TEAM**"""

print("Number of Unique Goalscorers 2023/24 Mid-Season: ", goals24_mod['Player Name'].nunique())

gscorers_per_team = goals24_mod.loc[goals24_mod["own_goal"]!=1]
gscorers_per_team

team_gscorers = gscorers_per_team.groupby("Team Name")['Player Name'].nunique().reset_index();
sorted_gscorers = team_gscorers.sort_values(by="Player Name", ascending=False)
sorted_gscorers.reset_index(drop=True)

"""### **GOALS IN CONSECUTIVE MATCHES**"""

# All Match Days Per Team
all_matchdays = {}
# Using df24 as the DataFrame
df24['Date'] = pd.to_datetime(df24['Date'], format='%d/%m/%Y')
sorted_df24 = df24.sort_values(by="Date")
for team in list_of_teams:
  team_df = sorted_df24.loc[(sorted_df24['Home Team'] == team) | (sorted_df24['Away Team'] == team)].reset_index(drop=True)
  # convert date back to string object
  team_df['Date'] = team_df.Date.astype(str)
  # Get all date strings
  match_days = team_df.Date.unique()
  # update dictionary
  all_matchdays[team] = list(match_days)

# view dictionary
all_matchdays

show_all_cells(False)
goals24_mod['Player Name'].value_counts()

multiple_goals = goals24_mod['Player Name'].value_counts().reset_index()
multiple_goals = multiple_goals[multiple_goals['Player Name']>1]
multiple_goals.head()

print("Only {} Players Have Scored More Than One Goal at 2023/24 Mid-Season and they have {} goals between them!".format(len(multiple_goals), multiple_goals['Player Name'].sum()))

multiple_gscorers_list = multiple_goals['index'].to_list()

show_all_cells(False)
consec_gms = goals24_mod[goals24_mod['Player Name'].isin(multiple_gscorers_list)]
consec_gms = consec_gms.reset_index(drop=True)
# Dropping all instances of own goals (incase they sneaked past the first checkpoint)
consec_gms = consec_gms.loc[consec_gms['own_goal'] !=1]

consec_gms.head()

consec_gms.info()

# convert to datetime
consec_gms['Date'] = pd.to_datetime(consec_gms['Date'], format='%d/%m/%Y')
# sort by Date
sorted_consec = consec_gms.sort_values(by="Date")
sorted_consec = sorted_consec.reset_index(drop=True)
sorted_consec

# All Matchdays Where Each Goalscorer Scored at least one Goal
grouped_consec = sorted_consec.groupby(['Player Name', 'Team Name'])['Date'].unique()
grouped_consec = grouped_consec.reset_index()
grouped_consec

# Dropping rows where multiple goals were scored but it was just in one match
indices_to_delete = []
for i in range(len(grouped_consec)):
  if len(grouped_consec['Date'][i]) <= 1:
    indices_to_delete.append(i)

# Delete rows by index
grouped_consec.drop(indices_to_delete, inplace=True)
grouped_consec = grouped_consec.reset_index(drop=True)
grouped_consec

# store final streak list per player
player_goals = {}

for i, datelist in enumerate(grouped_consec['Date']):
    # fetching team match days from all_matchdays
    matchday = all_matchdays.get(grouped_consec['Team Name'][i])
    # getting a sorted list of dates when the player scored
    date = sorted(datelist)

    # comparing dates
    matches = []  # reset matches for each player
    j = k = 0  # reset indices for each player
    while j < len(date) and k < len(matchday):
        formatted_date = pd.to_datetime(date[j]).strftime('%Y%m%d')
        formatted_matchday = pd.to_datetime(matchday[k]).strftime('%Y%m%d')
        #
        if formatted_date == formatted_matchday:
            matches.append(1)
            j += 1
            k += 1
        else:
            matches.append(0)
            k += 1
    # check if there are remaining match days
    while k < len(matchday):
        matches.append(0)
        k += 1
    # Join the binary list into a string
    match_string = ''.join(map(str, matches))
    # update dictionary
    player_goals[grouped_consec['Player Name'][i]] = match_string

# view dictionary
player_goals

# Create a list to store streak information
streak_data = []

# Iterate over player_goals dictionary
for player, match_string in player_goals.items():
    # Split match_string by '0' character and get the lengths of consecutive '1' streaks
    streaks = [len(streak) for streak in match_string.split('0')]

    # Get the maximum streak length
    max_streak = max(streaks)

    # Append player and max_streak to streak_data
    streak_data.append({'Name': player, 'Streak': max_streak})

# Create DataFrame from streak_data
streak_df = pd.DataFrame(streak_data)

# Filter rows where the streak is greater than 1
streak_df = streak_df[streak_df['Streak'] > 1]

# Reset index
streak_df = streak_df.reset_index(drop=True)

# Sort by Streak
streak_df = streak_df.sort_values('Streak', ascending=False)

# Reset index again
streak_df = streak_df.reset_index(drop=True)
streak_df

"""#### **ON HOW MANY MATCHDAYS HAVE THE TEAMS SCORED THIS SEASON ?**"""

# Match Days When The Teams Scored
md_scored = {}
# Assuming df is your DataFrame
goals24['Date'] = pd.to_datetime(goals24['Date'], format='%d/%m/%Y')
sorted_goals24 = goals24.sort_values(by="Date")
for team in sorted(goals24['Team Name'].unique()):
  team_df = sorted_goals24.loc[sorted_goals24['Team Name'] == team].reset_index(drop=True)
  # convert date back to string object
  team_df['Date'] = team_df.Date.astype(str)
  # et the match days list in ascending order
  match_days = team_df.Date.unique()
  # update dictionary
  md_scored[team] = list(match_days)

# view dictionary
md_scored

for key in md_scored.keys():
  print("{} has scored on ({}) out of 7 matchdays this season".format(key, len(md_scored.get(key))))

# Convert dictionary to DataFrame
df = pd.DataFrame(list(md_scored.items()), columns=['Teams', 'Matchdays'])
# Update "Matchdays" column with the length of each list
df['Matchdays'] = df['Matchdays'].apply(len)
df.sort_values(by="Matchdays", ascending=False).reset_index(drop=True)

"""### **COMMON SCORELINES**

Common Scorelines - May Be Expressed In Pct or Prob

#### **COMBINED**

#####**PROBABILITY DISTRIBUTION**
"""

# Total Number of Games
num_of_gms = len(df24)

# cols to fetch data
h_teams = df24['FTHG']
a_teams = df24['FTAG']

# Get the maximum values of FTTG and FTOG
max_fthg = max(df24['FTHG'])
max_ftag = max(df24['FTAG'])

# Get Threshold for Text Label Color
threshold_df = df24[['FTHG', 'FTAG']].value_counts().reset_index()


# Create the figure
fig, ax = plt.subplots(1,1, figsize=(10, 6), facecolor=facecolor)
# Create a 2D histogram
heatmap, xedges, yedges = np.histogram2d(h_teams, a_teams,
                                          bins=(np.arange(max_fthg + 2), np.arange(max_ftag + 2)))

# Define a custom colormap with darkgreen
cmap = plt.get_cmap('Blues')#.copy()
#cmap.set_under(color=ax_color)

# ax tick text xolors
ax.tick_params(axis='both', colors=off_white)
hide_spines(axes=ax, which_spine="all")

# Plot the heatmap
plt.imshow(heatmap.T, cmap=cmap, vmin=0, vmax=np.max(heatmap), origin='lower', interpolation='none')

# Set xticks and yticks to match the range of possible scorelines
plt.xticks(np.arange(max_fthg + 1))
plt.yticks(np.arange(max_ftag + 1))

# Show the colorbar with reversed intensity
cbar = plt.colorbar(label='Frequency', orientation='vertical', extend='max')

# Set text properties for colorbar labels
cbar.ax.set_ylabel('Num of Matches', rotation=270, labelpad=20,
                    fontsize=12, color=off_white)

cbar.ax.tick_params(axis='y', colors=off_white)
cbar_spines = ['top','bottom','left','right']
for spine in cbar_spines:
    cbar.ax.spines[spine].set_visible(False)

# Geting the cbar ticks
tick_values = cbar.get_ticks()
# Threshold for adjusting text color based on intensity of cell
threshold = int(max(tick_values)/2)

# Print the frequency on top of each cell
for i in range(len(xedges) - 1):
    for j in range(len(yedges) - 1):
        if len(df24[(df24['FTHG'] == i) & (df24['FTAG'] == j)]) < threshold:
            cnt_color = 'black'
        else:
            cnt_color = off_white
        if heatmap[i, j] != 0:
            # Expressing Results in Percentages Instead of the Num of Games for eachresult
            pct = (int(heatmap[i, j])/num_of_gms)*100
            # Expressing Results in Probabilities Instead of the Num of Games for eachresult
            prob = pct/100
            # Priniting Values
            match_cnt = ax.text(i+0.03, j+0.03, '{0:.2f}'.format(prob), color=cnt_color,
                                ha='center', va='center', fontsize=14, fontweight='bold')
            match_cnt.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                                            path_effects.Normal()])

# Add labels and title
_ylabel = 'Away Team Goals'
_xlabel = 'Home Team Goals'

title_text = (f'PROB. DISTRIBUTION OF FULL TIME RESULTS \n{df24_season.upper()} NWFL MID SEASON')

# ANNOTATIONS
# ylabel Text
ylabel_text= fig.text(x=0.02, y= .50, s=_ylabel, ha='center', va='center', rotation=90,
                      linespacing=2.2, color=off_white, fontweight='semibold', fontsize=12, zorder=2)
ylabel_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                        path_effects.Normal()])

# xlabel Text
xlabel_text= fig.text(x=.45, y=0, s=_xlabel, ha='center', va='center', linespacing=2.2, color=off_white, fontweight='semibold', fontsize=12, zorder=2)
xlabel_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                        path_effects.Normal()])

# Title Text
title = fig.text(x=0.48, y=1.0, s=title_text, ha='center', va='center', linespacing=2.2, color=off_white, fontweight='semibold', fontsize=14, zorder=2)
title.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                        path_effects.Normal()])


#  Name Text
name_text = fig.text(x=0.45, y=-.22, s=author, ha='center', va='center', color=plot_color, alpha=.3, fontsize=12, zorder=2)
name_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                            path_effects.Normal()])

# Pad Top
fig.text(x=0.5, y= 0.01, s=pad_top, color=off_white, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
# Pad Bottom
fig.text(x=0.5, y= -.25, s=pad_end, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
## Pad left
fig.text(x=-.15, y= 1.15, s=hspace, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
# Pad Right
fig.text(x=1.06, y=0, s=hspace, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
# Save Figure
plt.savefig("/content/drive/MyDrive/NWFL/plots/prob_ft_scores_23_24_mid_nwfl.png", dpi=100)
plt.show();

# Total Number of Games
num_of_gms = len(df24)

# cols to fetch data
h_teams = df24['HTHG']
a_teams = df24['HTAG']

# Get the maximum values of FTTG and FTOG
max_fthg = max(df24['HTHG'])
max_ftag = max(df24['HTAG'])

# Get Threshold for Text Label Color
threshold_df = df24[['HTHG', 'HTAG']].value_counts().reset_index()


# Create the figure
fig, ax = plt.subplots(1,1, figsize=(10, 6), facecolor=facecolor)
# Create a 2D histogram
heatmap, xedges, yedges = np.histogram2d(h_teams, a_teams,
                                          bins=(np.arange(max_fthg + 2), np.arange(max_ftag + 2)))

# Define a custom colormap with darkgreen
cmap = plt.get_cmap('Blues')#.copy()
#cmap.set_under(color=ax_color)

# ax tick text xolors
ax.tick_params(axis='both', colors=off_white)
hide_spines(axes=ax, which_spine="all")

# Plot the heatmap
plt.imshow(heatmap.T, cmap=cmap, vmin=0, vmax=np.max(heatmap), origin='lower', interpolation='none')

# Set xticks and yticks to match the range of possible scorelines
plt.xticks(np.arange(max_fthg + 1))
plt.yticks(np.arange(max_ftag + 1))

# Show the colorbar with reversed intensity
cbar = plt.colorbar(label='Frequency', orientation='vertical', extend='max')

# Set text properties for colorbar labels
cbar.ax.set_ylabel('Num of Matches', rotation=270, labelpad=20,
                    fontsize=12, color=off_white)

cbar.ax.tick_params(axis='y', colors=off_white)
cbar_spines = ['top','bottom','left','right']
for spine in cbar_spines:
    cbar.ax.spines[spine].set_visible(False)

# Geting the cbar ticks
tick_values = cbar.get_ticks()
# Threshold for adjusting text color based on intensity of cell
threshold = int(max(tick_values)/2)

# Print the frequency on top of each cell
for i in range(len(xedges) - 1):
    for j in range(len(yedges) - 1):
        if len(df24[(df24['HTHG'] == i) & (df24['HTAG'] == j)]) < threshold:
            cnt_color = 'black'
        else:
            cnt_color = off_white
        if heatmap[i, j] != 0:
            # Expressing Results in Percentages Instead of the Num of Games for eachresult
            pct = (int(heatmap[i, j])/num_of_gms)*100
            # Expressing Results in Probabilities Instead of the Num of Games for eachresult
            prob = pct/100
            # Priniting Values
            match_cnt = ax.text(i+0.03, j+0.03, '{0:.2f}'.format(prob), color=cnt_color,
                                ha='center', va='center', fontsize=14, fontweight='bold')
            match_cnt.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                                            path_effects.Normal()])

# Add labels and title
_ylabel = 'Away Team Goals'
_xlabel = 'Home Team Goals'

title_text = (f'PROB. DISTRIBUTION OF HALF TIME RESULTS \n{df24_season.upper()} NWFL MID SEASON')

# ANNOTATIONS
# ylabel Text
ylabel_text= fig.text(x=0.02, y= .50, s=_ylabel, ha='center', va='center', rotation=90,
                      linespacing=2.2, color=off_white, fontweight='semibold', fontsize=12, zorder=2)
ylabel_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                        path_effects.Normal()])

# xlabel Text
xlabel_text= fig.text(x=.45, y=0, s=_xlabel, ha='center', va='center', linespacing=2.2, color=off_white, fontweight='semibold', fontsize=12, zorder=2)
xlabel_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                        path_effects.Normal()])

# Title Text
title = fig.text(x=0.48, y=1.0, s=title_text, ha='center', va='center', linespacing=2.2, color=off_white, fontweight='semibold', fontsize=14, zorder=2)
title.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                        path_effects.Normal()])


#  Name Text
name_text = fig.text(x=0.45, y=-.22, s=author, ha='center', va='center', color=plot_color, alpha=.3, fontsize=12, zorder=2)
name_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                            path_effects.Normal()])

# Pad Top
fig.text(x=0.5, y= 0.01, s=pad_top, color=off_white, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
# Pad Bottom
fig.text(x=0.5, y= -.25, s=pad_end, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
## Pad left
fig.text(x=-.15, y= 1.15, s=hspace, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
# Pad Right
fig.text(x=1.06, y=0, s=hspace, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
# Save Fig
plt.savefig("/content/drive/MyDrive/NWFL/plots/prob_ht_scores_23_24_mid_nwfl.png", dpi=200)
plt.show();

# Total Number of Games
num_of_gms = len(df24)

# cols to fetch data
h_teams = df24['SHHG']
a_teams = df24['SHAG']

# Get the maximum values of FTTG and FTOG
max_fthg = max(df24['SHHG'])
max_ftag = max(df24['SHAG'])

# Get Threshold for Text Label Color
threshold_df = df24[['SHHG', 'SHAG']].value_counts().reset_index()


# Create the figure
fig, ax = plt.subplots(1,1, figsize=(10, 6), facecolor=facecolor)
# Create a 2D histogram
heatmap, xedges, yedges = np.histogram2d(h_teams, a_teams,
                                          bins=(np.arange(max_fthg + 2), np.arange(max_ftag + 2)))

# Define a custom colormap with darkgreen
cmap = plt.get_cmap('Blues')#.copy()
#cmap.set_under(color=ax_color)

# ax tick text xolors
ax.tick_params(axis='both', colors=off_white)
hide_spines(axes=ax, which_spine="all")

# Plot the heatmap
plt.imshow(heatmap.T, cmap=cmap, vmin=0, vmax=np.max(heatmap), origin='lower', interpolation='none')

# Set xticks and yticks to match the range of possible scorelines
plt.xticks(np.arange(max_fthg + 1))
plt.yticks(np.arange(max_ftag + 1))

# Show the colorbar with reversed intensity
cbar = plt.colorbar(label='Frequency', orientation='vertical', extend='max')

# Set text properties for colorbar labels
cbar.ax.set_ylabel('Num of Matches', rotation=270, labelpad=20,
                    fontsize=12, color=off_white)

cbar.ax.tick_params(axis='y', colors=off_white)
cbar_spines = ['top','bottom','left','right']
for spine in cbar_spines:
    cbar.ax.spines[spine].set_visible(False)

# Geting the cbar ticks
tick_values = cbar.get_ticks()
# Threshold for adjusting text color based on intensity of cell
threshold = int(max(tick_values)/2)

# Print the frequency on top of each cell
for i in range(len(xedges) - 1):
    for j in range(len(yedges) - 1):
        if len(df24[(df24['SHHG'] == i) & (df24['SHAG'] == j)]) < threshold:
            cnt_color = 'black'
        else:
            cnt_color = off_white
        if heatmap[i, j] != 0:
            # Expressing Results in Percentages Instead of the Num of Games for eachresult
            pct = (int(heatmap[i, j])/num_of_gms)*100
            # Expressing Results in Probabilities Instead of the Num of Games for eachresult
            prob = pct/100
            # Priniting Values
            match_cnt = ax.text(i+0.03, j+0.03, '{0:.2f}'.format(prob), color=cnt_color,
                                ha='center', va='center', fontsize=14, fontweight='bold')
            match_cnt.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                                            path_effects.Normal()])

# Add labels and title
_ylabel = 'Away Team Goals'
_xlabel = 'Home Team Goals'

title_text = (f'PROB. DISTRIBUTION OF SECOND HALF RESULTS \n{df24_season.upper()} NWFL MID SEASON')

# ANNOTATIONS
# ylabel Text
ylabel_text= fig.text(x=0.02, y= .50, s=_ylabel, ha='center', va='center', rotation=90,
                      linespacing=2.2, color=off_white, fontweight='semibold', fontsize=12, zorder=2)
ylabel_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                        path_effects.Normal()])

# xlabel Text
xlabel_text= fig.text(x=.45, y=0, s=_xlabel, ha='center', va='center', linespacing=2.2, color=off_white, fontweight='semibold', fontsize=12, zorder=2)
xlabel_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                        path_effects.Normal()])

# Title Text
title = fig.text(x=0.48, y=1.0, s=title_text, ha='center', va='center', linespacing=2.2, color=off_white, fontweight='semibold', fontsize=14, zorder=2)
title.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                        path_effects.Normal()])


#  Name Text
name_text = fig.text(x=0.45, y=-.22, s=author, ha='center', va='center', color=plot_color, alpha=.3, fontsize=12, zorder=2)
name_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                            path_effects.Normal()])

# Pad Top
fig.text(x=0.5, y= 0.01, s=pad_top, color=off_white, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
# Pad Bottom
fig.text(x=0.5, y= -.25, s=pad_end, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
## Pad left
fig.text(x=-.15, y= 1.15, s=hspace, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
# Pad Right
fig.text(x=1.06, y=0, s=hspace, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
# Save Fig
plt.savefig("/content/drive/MyDrive/NWFL/plots/prob_sh_scores_23_24_mid_nwfl.png", dpi=200)
plt.show();

"""#####**PERCENTAGE DISTRIBUTION**"""

# Total Number of Games
num_of_gms = len(df24)

# cols to fetch data
h_teams = df24['FTHG']
a_teams = df24['FTAG']

# Get the maximum values of FTTG and FTOG
max_fthg = max(df24['FTHG'])
max_ftag = max(df24['FTAG'])

# Get Threshold for Text Label Color
threshold_df = df24[['FTHG', 'FTAG']].value_counts().reset_index()


# Create the figure
fig, ax = plt.subplots(1,1, figsize=(10, 6), facecolor=facecolor)
# Create a 2D histogram
heatmap, xedges, yedges = np.histogram2d(h_teams, a_teams,
                                          bins=(np.arange(max_fthg + 2), np.arange(max_ftag + 2)))

# Define a custom colormap with darkgreen
cmap = plt.get_cmap('Blues')#.copy()
#cmap.set_under(color=ax_color)

# ax tick text xolors
ax.tick_params(axis='both', colors=off_white)
hide_spines(axes=ax, which_spine="all")

# Plot the heatmap
plt.imshow(heatmap.T, cmap=cmap, vmin=0, vmax=np.max(heatmap), origin='lower', interpolation='none')

# Set xticks and yticks to match the range of possible scorelines
plt.xticks(np.arange(max_fthg + 1))
plt.yticks(np.arange(max_ftag + 1))

# Show the colorbar with reversed intensity
cbar = plt.colorbar(label='Frequency', orientation='vertical', extend='max')

# Set text properties for colorbar labels
cbar.ax.set_ylabel('Num of Matches', rotation=270, labelpad=20,
                    fontsize=12, color=off_white)

cbar.ax.tick_params(axis='y', colors=off_white)
cbar_spines = ['top','bottom','left','right']
for spine in cbar_spines:
    cbar.ax.spines[spine].set_visible(False)

# Geting the cbar ticks
tick_values = cbar.get_ticks()
# Threshold for adjusting text color based on intensity of cell
threshold = int(max(tick_values)/2)

# Print the frequency on top of each cell
for i in range(len(xedges) - 1):
    for j in range(len(yedges) - 1):
        if len(df24[(df24['FTHG'] == i) & (df24['FTAG'] == j)]) < threshold:
            cnt_color = 'black'
        else:
            cnt_color = off_white
        if heatmap[i, j] != 0:
            # Expressing Results in Percentages Instead of the Num of Games for eachresult
            pct = (int(heatmap[i, j])/num_of_gms)*100
            # Priniting Percentages
            match_cnt = ax.text(i+0.03, j+0.03, '{0:.2f}'.format(pct), color=cnt_color,
                                ha='center', va='center', fontsize=14, fontweight='bold')
            match_cnt.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                                            path_effects.Normal()])

# Add labels and title
_ylabel = 'Away Team Goals'
_xlabel = 'Home Team Goals'

title_text = (f'%DISTRIBUTION OF FULL TIME RESULTS {df24_season} NWFL SEASON'.upper())

# ANNOTATIONS
# ylabel Text
ylabel_text= fig.text(x=0.02, y= .50, s=_ylabel, ha='center', va='center', rotation=90,
                      linespacing=2.2, color=off_white, fontweight='semibold', fontsize=12, zorder=2)
ylabel_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                        path_effects.Normal()])

# xlabel Text
xlabel_text= fig.text(x=.45, y=0, s=_xlabel, ha='center', va='center', linespacing=2.2, color=off_white, fontweight='semibold', fontsize=12, zorder=2)
xlabel_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                        path_effects.Normal()])

# Title Text
title = fig.text(x=0.48, y=1.0, s=title_text, ha='center', va='center', linespacing=2.2, color=off_white, fontweight='semibold', fontsize=14, zorder=2)
title.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                        path_effects.Normal()])


#  Name Text
name_text = fig.text(x=0.45, y=-.22, s=author, ha='center', va='center', color=plot_color, alpha=.3, fontsize=12, zorder=2)
name_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                            path_effects.Normal()])

# Pad Top
fig.text(x=0.5, y= 0.01, s=pad_top, color=off_white, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
# Pad Bottom
fig.text(x=0.5, y= -.25, s=pad_end, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
## Pad left
fig.text(x=-.15, y= 1.15, s=hspace, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
# Pad Right
fig.text(x=1.06, y=0, s=hspace, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
# Save Fig
plt.savefig("/content/drive/MyDrive/NWFL/plots/pct_dist_ft_scores_23_24_mid_nwfl.png", dpi=100)
plt.show();

# Total Number of Games
num_of_gms = len(df24)

# cols to fetch data
h_teams = df24['HTHG']
a_teams = df24['HTAG']

# Get the maximum values of FTTG and FTOG
max_fthg = max(df24['HTHG'])
max_ftag = max(df24['HTAG'])

# Get Threshold for Text Label Color
threshold_df = df24[['HTHG', 'HTAG']].value_counts().reset_index()


# Create the figure
fig, ax = plt.subplots(1,1, figsize=(10, 6), facecolor=facecolor)
# Create a 2D histogram
heatmap, xedges, yedges = np.histogram2d(h_teams, a_teams,
                                          bins=(np.arange(max_fthg + 2), np.arange(max_ftag + 2)))

# Define a custom colormap with darkgreen
cmap = plt.get_cmap('Blues')#.copy()
#cmap.set_under(color=ax_color)

# ax tick text xolors
ax.tick_params(axis='both', colors=off_white)
hide_spines(axes=ax, which_spine="all")

# Plot the heatmap
plt.imshow(heatmap.T, cmap=cmap, vmin=0, vmax=np.max(heatmap), origin='lower', interpolation='none')

# Set xticks and yticks to match the range of possible scorelines
plt.xticks(np.arange(max_fthg + 1))
plt.yticks(np.arange(max_ftag + 1))

# Show the colorbar with reversed intensity
cbar = plt.colorbar(label='Frequency', orientation='vertical', extend='max')

# Set text properties for colorbar labels
cbar.ax.set_ylabel('Num of Matches', rotation=270, labelpad=20,
                    fontsize=12, color=off_white)

cbar.ax.tick_params(axis='y', colors=off_white)
cbar_spines = ['top','bottom','left','right']
for spine in cbar_spines:
    cbar.ax.spines[spine].set_visible(False)

# Geting the cbar ticks
tick_values = cbar.get_ticks()
# Threshold for adjusting text color based on intensity of cell
threshold = int(max(tick_values)/2)

# Print the frequency on top of each cell
for i in range(len(xedges) - 1):
    for j in range(len(yedges) - 1):
        if len(df24[(df24['HTHG'] == i) & (df24['HTAG'] == j)]) < threshold:
            cnt_color = 'black'
        else:
            cnt_color = off_white
        if heatmap[i, j] != 0:
            # Expressing Results in Percentages Instead of the Num of Games for eachresult
            pct = (int(heatmap[i, j])/num_of_gms)*100
            # Expressing Results in Probabilities Instead of the Num of Games for eachresult
            prob = pct/100
            # Priniting Values
            match_cnt = ax.text(i+0.03, j+0.03, '{0:.2f}'.format(pct), color=cnt_color,
                                ha='center', va='center', fontsize=14, fontweight='bold')
            match_cnt.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                                            path_effects.Normal()])

# Add labels and title
_ylabel = 'Away Team Goals'
_xlabel = 'Home Team Goals'

title_text = (f'%DISTRIBUTION OF HALF TIME RESULTS \n{df24_season.upper()} NWFL MID SEASON')

# ANNOTATIONS
# ylabel Text
ylabel_text= fig.text(x=0.02, y= .50, s=_ylabel, ha='center', va='center', rotation=90,
                      linespacing=2.2, color=off_white, fontweight='semibold', fontsize=12, zorder=2)
ylabel_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                        path_effects.Normal()])

# xlabel Text
xlabel_text= fig.text(x=.45, y=0, s=_xlabel, ha='center', va='center', linespacing=2.2, color=off_white, fontweight='semibold', fontsize=12, zorder=2)
xlabel_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                        path_effects.Normal()])

# Title Text
title = fig.text(x=0.48, y=1.0, s=title_text, ha='center', va='center', linespacing=2.2, color=off_white, fontweight='semibold', fontsize=14, zorder=2)
title.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                        path_effects.Normal()])


#  Name Text
name_text = fig.text(x=0.45, y=-.22, s=author, ha='center', va='center', color=plot_color, alpha=.3, fontsize=12, zorder=2)
name_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                            path_effects.Normal()])

# Pad Top
fig.text(x=0.5, y= 0.01, s=pad_top, color=off_white, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
# Pad Bottom
fig.text(x=0.5, y= -.25, s=pad_end, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
## Pad left
fig.text(x=-.15, y= 1.15, s=hspace, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
# Pad Right
fig.text(x=1.06, y=0, s=hspace, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
# Save Fig
plt.savefig("/content/drive/MyDrive/NWFL/plots/pct_dist_ht_scores_23_24_mid_nwfl.png", dpi=100)
plt.show();

# Total Number of Games
num_of_gms = len(df24)

# cols to fetch data
h_teams = df24['SHHG']
a_teams = df24['SHAG']

# Get the maximum values of FTTG and FTOG
max_fthg = max(df24['SHHG'])
max_ftag = max(df24['SHAG'])

# Get Threshold for Text Label Color
threshold_df = df24[['SHHG', 'SHAG']].value_counts().reset_index()


# Create the figure
fig, ax = plt.subplots(1,1, figsize=(10, 6), facecolor=facecolor)
# Create a 2D histogram
heatmap, xedges, yedges = np.histogram2d(h_teams, a_teams,
                                          bins=(np.arange(max_fthg + 2), np.arange(max_ftag + 2)))

# Define a custom colormap with darkgreen
cmap = plt.get_cmap('Blues')#.copy()
#cmap.set_under(color=ax_color)

# ax tick text xolors
ax.tick_params(axis='both', colors=off_white)
hide_spines(axes=ax, which_spine="all")

# Plot the heatmap
plt.imshow(heatmap.T, cmap=cmap, vmin=0, vmax=np.max(heatmap), origin='lower', interpolation='none')

# Set xticks and yticks to match the range of possible scorelines
plt.xticks(np.arange(max_fthg + 1))
plt.yticks(np.arange(max_ftag + 1))

# Show the colorbar with reversed intensity
cbar = plt.colorbar(label='Frequency', orientation='vertical', extend='max')

# Set text properties for colorbar labels
cbar.ax.set_ylabel('Num of Matches', rotation=270, labelpad=20,
                    fontsize=12, color=off_white)

cbar.ax.tick_params(axis='y', colors=off_white)
cbar_spines = ['top','bottom','left','right']
for spine in cbar_spines:
    cbar.ax.spines[spine].set_visible(False)

# Geting the cbar ticks
tick_values = cbar.get_ticks()
# Threshold for adjusting text color based on intensity of cell
threshold = int(max(tick_values)/2)

# Print the frequency on top of each cell
for i in range(len(xedges) - 1):
    for j in range(len(yedges) - 1):
        if len(df24[(df24['SHHG'] == i) & (df24['SHAG'] == j)]) < threshold:
            cnt_color = 'black'
        else:
            cnt_color = off_white
        if heatmap[i, j] != 0:
            # Expressing Results in Percentages Instead of the Num of Games for eachresult
            pct = (int(heatmap[i, j])/num_of_gms)*100
            # Expressing Results in Probabilities Instead of the Num of Games for eachresult
            prob = pct/100
            # Priniting Values
            match_cnt = ax.text(i+0.03, j+0.03, '{0:.2f}'.format(pct), color=cnt_color,
                                ha='center', va='center', fontsize=14, fontweight='bold')
            match_cnt.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                                            path_effects.Normal()])

# Add labels and title
_ylabel = 'Away Team Goals'
_xlabel = 'Home Team Goals'

title_text = (f'%DISTRIBUTION OF SECOND HALF RESULTS \n{df24_season.upper()} NWFL MID SEASON')

# ANNOTATIONS
# ylabel Text
ylabel_text= fig.text(x=0.02, y= .50, s=_ylabel, ha='center', va='center', rotation=90,
                      linespacing=2.2, color=off_white, fontweight='semibold', fontsize=12, zorder=2)
ylabel_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                        path_effects.Normal()])

# xlabel Text
xlabel_text= fig.text(x=.45, y=0, s=_xlabel, ha='center', va='center', linespacing=2.2, color=off_white, fontweight='semibold', fontsize=12, zorder=2)
xlabel_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                        path_effects.Normal()])

# Title Text
title = fig.text(x=0.48, y=1.0, s=title_text, ha='center', va='center', linespacing=2.2, color=off_white, fontweight='semibold', fontsize=14, zorder=2)
title.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                        path_effects.Normal()])


#  Name Text
name_text = fig.text(x=0.45, y=-.22, s=author, ha='center', va='center', color=plot_color, alpha=.3, fontsize=12, zorder=2)
name_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                            path_effects.Normal()])

# Pad Top
fig.text(x=0.5, y= 0.01, s=pad_top, color=off_white, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
# Pad Bottom
fig.text(x=0.5, y= -.25, s=pad_end, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
## Pad left
fig.text(x=-.15, y= 1.15, s=hspace, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
# Pad Right
fig.text(x=1.06, y=0, s=hspace, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
# Save Fig
plt.savefig("/content/drive/MyDrive/NWFL/plots/pct_dist_sh_scores_23_24_mid_nwfl.png", dpi=100)
plt.show();

"""#### **PER GROUP**"""



"""#### **PER TEAM**"""



"""## **HOME VERSUS AWAY (RESULT DISTRIBUTION & GOALS) IN COMPARSION TO 2022/23**"""

print("Goals Scored in 2023/24 NWFL Mid-Season by Home Teams: ", df24.FTHG.sum())
print("Goals Scored in 2023/24 NWFL Mid-Season by Away Teams: ", df24.FTAG.sum())

print("Goals Scored in 2022/23 NWFL Mid-Season by Home Teams: ", df23.FTHG.sum())
print("Goals Scored in 2022/23 NWFL Mid-Season by Away Teams: ", df23.FTAG.sum())

# Calculating The Total Goals Scored In The 2022/23 Season
total_goals23 = df23.FTHG.sum() + df23.FTAG.sum()
print("Total Goals Scored in 2022/23 NWFL Mid-Season: ", total_goals23)
print("Total Games Played in 2022/23 NWFL Mid-Season: ", len(df23))
print("League Goals Avg in 2022/23 NWFL Mid-Season: ", round(total_goals23/len(df23), 2))

#
ax = sns.countplot(x = df24['FTR'] , data = df24, color=plot_color, order=['H','A','D'])
for container in ax.containers:
    ax.bar_label(container)

ax = sns.countplot(x = df23['FTR'] , data = df23, color=plot_color, order=['H','A','D'])
for container in ax.containers:
    ax.bar_label(container)

import matplotlib.pyplot as plt

# Sample data
game_weeks = [1, 2, 3, 4, 5, 6, 7]
home_wins = [6, 4, 4, 2, 3, 2, 3]
away_wins = [0, 1, 1, 1, 1, 2, 1]
draws = [0, 1, 1, 3, 2, 2, 2]

# Bar plot
bar_width = 0.25
index = range(len(game_weeks))

plt.bar(index, home_wins, width=bar_width, label='Home Wins')
plt.bar([i + bar_width for i in index], away_wins, width=bar_width, label='Away Wins')
plt.bar([i + 2 * bar_width for i in index], draws, width=bar_width, label='Draws')

plt.xlabel('Game Week')
plt.ylabel('')
plt.title('Distribution of Home Wins, Away Wins, and Draws Per Game Week')
plt.xticks([i + bar_width for i in index], game_weeks)
plt.legend()

plt.show();

"""## **RESULT DISTRIBUTION PER MW**"""

# Group by 'GameWeek' and count the occurrences of each 'FTR' value
result24 = df24.groupby(['Game Week', 'FTR']).size().unstack(fill_value=0)

# Rename columns for better clarity
result24.columns = ['Draws', 'Away Wins', 'Home Wins']

# Reset Index
result24 = result24.reset_index()

# Display the result
result24

# Group by 'GameWeek' and count the occurrences of each 'FTR' value
result23 = df23.groupby(['Game Week', 'FTR']).size().unstack(fill_value=0)

# Rename columns for better clarity
result23.columns = ['Draws', 'Away Wins', 'Home Wins']

# Reset Index
result23 = result23.reset_index()

# Display the result
result23

"""##**GD ANALYSES**

#####**GD DATAFRAME**
"""

gd_df = df24[['Home Team', 'Away Team', 'FTHG', 'FTAG',
              'FTR', 'HomeTeam Goals', 'AwayTeam Goals']]

# Process Missing Values in HomeTeam Goals and AwayTeam Goals columns
# We're using 404 because it is a common error code and football matches don't reach 404 minutes
# It is formatted as a bracketed string for consistency with other rows
gd_df['HomeTeam Goals'] = gd_df['HomeTeam Goals'].fillna('(404)')
gd_df['AwayTeam Goals'] = gd_df['AwayTeam Goals'].fillna('(404)')

# Process HomeTeam Goals and AwayTeam Goals columns
gd_df['HomeTeam Goals'] = gd_df['HomeTeam Goals'].apply(extract_numbers)
gd_df['AwayTeam Goals'] = gd_df['AwayTeam Goals'].apply(extract_numbers)

gd_df.head(3);

"""####**GD CHART**"""

grp_a, _a = calculate_standings(df=df24, game_week=7, group='a')
grp_b, _b = calculate_standings(df=df24, game_week=7, group='b')
grp_a
grp_b

grp_a23, _a23 = calculate_standings(df=df23, game_week=7, group='a')
grp_b23, _b23 = calculate_standings(df=df23, game_week=7, group='b')
grp_a23
grp_b23

"""###**%MINUTES TRAILING, LEADING OR DRAWING PER TEAM**"""

gd_df.head(10)







"""###**MATCH OPENERS**

####**WRANGLE ACT**
"""

gls_gms = df24.loc[(df24['FTHG'] != 0) | (df24['FTAG'] != 0)]
len(gls_gms)

no_gls_in_gms = df24.loc[(df24['FTHG'] == 0) & (df24['FTAG'] == 0)]
len(no_gls_in_gms)

# select dataframe
df = gd_df.copy()

# Pts_Pos Dict of Dataframes
Pts_Pos = {}
# Create opener dictionaries
opener_home = {}
opener_away = {}

for team in list_of_teams:
    # Get the team dataframe
    x = df.loc[(df['Home Team'] == team) | (df['Away Team'] == team)]
    # Replacing with the time of first goal
    x['HomeTeam Goals'] = x['HomeTeam Goals'].apply(lambda x: min(map(int, x)) if isinstance(x, list) else x)
    x['AwayTeam Goals'] = x['AwayTeam Goals'].apply(lambda x: min(map(int, x)) if isinstance(x, list) else x)

    # subset dfs
    x_home = x.loc[x['Home Team']==team]
    x_away = x.loc[x['Away Team']==team]

    # 1 for when team scored opener
    # -1 for when they conceded the opener
    # 0 for goalless affairs
    x_home['opener'] = np.where(x_home['HomeTeam Goals'] > x_home['AwayTeam Goals'], -1,
                                np.where(x_home['HomeTeam Goals'] < x_home['AwayTeam Goals'], 1, 0))
    # same as x_home
    x_away['opener'] = np.where(x_away['HomeTeam Goals'] < x_away['AwayTeam Goals'], -1,
                                np.where(x_away['HomeTeam Goals'] > x_away['AwayTeam Goals'], 1, 0))
    # reset dfs
    x_home = x_home.reset_index(drop=True)
    x_away = x_away.reset_index(drop=True)

    # Updating Pts_Pos Dataframe
    Pts_Pos[team] = pd.concat([x_home,x_away], ignore_index='True')

    # Populate opener_home dictionary
    # calculating dictionary values
    opener_scored = x_home['opener'].value_counts().get(1,0)
    opener_conc = x_home['opener'].value_counts().get(-1,0)
    # populate dictionary
    opener_home[team] = {'scored_home': int(opener_scored), 'conc_home': int(opener_conc)}

    # Populate opener_away dictionary
    # calculating dictionary values
    opener_scored = x_away['opener'].value_counts().get(1,0)
    opener_conc = x_away['opener'].value_counts().get(-1,0)
    # populate dictionary
    opener_away[team] = {'scored_away': int(opener_scored), 'conc_away': int(opener_conc)}

# Create DataFrames from both dictionaries
_away = pd.DataFrame(opener_away).transpose().reset_index()
# Rename columns
_away.columns = ['Team', 'scored_away', 'conceded_away']
# sort
sorted_away = _away.sort_values(by="Team")

# Create DataFrames from the Home dictionary
_home = pd.DataFrame(opener_home).transpose().reset_index()
# Rename columns
_home.columns = ['Team', 'scored_home', 'conceded_home']
# sort
sorted_home = _home.sort_values(by="Team")

# Concatenate DataFrames
opener_df = pd.merge(sorted_home, sorted_away, on="Team")

# Viewing dataframe
opener_df["Total_Scored"] = opener_df.scored_home + opener_df.scored_away
opener_df["Total_Conceded"] = opener_df.conceded_home + opener_df.conceded_away

# View Dataframe
opener_df

# Confirming the counts of the openers_df
# Using two because for every opner scored, it was also conceded by the opposing team so each opener has a double count
2*len(gls_gms) == opener_df.scored_home.sum() +	opener_df.conceded_home.sum() +	opener_df.scored_away.sum() + opener_df.conceded_away.sum()

"""####**MOST OPENERS SCORED**"""

# Most Openers Combined
opener_df[['Team','Total_Scored']].sort_values(by="Total_Scored", ascending=False).reset_index(drop=True)

# Most Openers At Home
opener_df[['Team','scored_home']].sort_values(by="scored_home", ascending=False).reset_index(drop=True)

# Most Openers Away
opener_df[['Team','scored_away']].sort_values(by="scored_away", ascending=False).reset_index(drop=True)

"""####**MOST OPENERS CONCEDED**"""

# Most Openers Combined
opener_df[['Team','Total_Conceded']].sort_values(by="Total_Conceded", ascending=False).reset_index(drop=True)

# Most Openers At Home
opener_df[['Team','conceded_home']].sort_values(by="conceded_home", ascending=False).reset_index(drop=True)

# Most Openers Away
opener_df[['Team','conceded_away']].sort_values(by="conceded_away", ascending=False).reset_index(drop=True)

"""###**PTS FROM POS**

####**POINTS WON FROM LOSING POSITIONS**

#####**WRANGLE ACT**
"""

# The Assumption is that winning at Home and Away have the same weights
# and it is not difficult to win at a stadium than another

# Init Value
draws = 1
wins = 3

# Dict
pts_frm_loss = {}

# Since the team must start by conceding, we need rows where opener is -1
for team in list_of_teams:
    # Resets points tally for each Team
    pts_tally = 0
    # Get Team Dataframe From Pts_Pos Dict
    # The Pts_Pos wass gotten from categorizing the games by match openers
    team_df = Pts_Pos.get(team, None)

    # Get df of where the team conceded first
    frm_loss_df = team_df.loc[team_df.opener == -1]
    # View each df in case of debugging
    # frm_loss_df

    for index, sub_df in frm_loss_df.iterrows():
        if sub_df['FTR'] == 'D':
          pts_tally +=draws
        elif (sub_df['Home Team'] == team):
          if sub_df['FTR'] == 'H':
              pts_tally +=wins
        elif sub_df['Away Team'] ==team:
          if sub_df['FTR'] == 'A':
              pts_tally +=wins

        pts_frm_loss[team] = pts_tally

# Uncomment for Debugging
# View Dict
# pts_frm_loss

# # Create DataFrames
pts_won_frm_loss_pos_df = pd.DataFrame(list(pts_frm_loss.items()), columns=['Team', 'Points Won'])
# pts_won_frm_loss_pos_df

"""#####**MOST POINTS WON FROM LOSING POSITIONS**"""

pts_won_frm_loss_pos_df.sort_values(by='Points Won', ascending=False).reset_index(drop=True)

"""####**POINTS DROPPED FROM WINNING POSITIONS**

#####**WRANGLE ACT**
"""

# The Assumption is that winning at Home and Away have the same weights
# and it is not difficult to win at a stadium than another

# Init Value
draws = -2
loss = -3

# Dict
pts_frm_win = {}

# Since the team must start by conceding, we need rows where opener is -1
for team in list_of_teams:
    # Resets points tally for each Team
    pts_tally = 0
    # Get Team Dataframe From Pts_Pos Dict
    # The Pts_Pos wass gotten from categorizing the games by match openers
    team_df = Pts_Pos.get(team, None)

    # Get df of where the team conceded first
    frm_win_df = team_df.loc[team_df.opener == 1]
    # # Uncomment for debugging to seeeach team df
    # frm_win_df

    for index, sub_df in frm_win_df.iterrows():
        if sub_df['FTR'] == 'D':
          pts_tally +=draws
        elif (sub_df['Home Team'] == team):
          if sub_df['FTR'] == 'A':
              pts_tally +=loss
        elif sub_df['Away Team'] ==team:
          if sub_df['FTR'] == 'H':
              pts_tally +=loss

        pts_frm_win[team] = abs(pts_tally)

# # Uncomment for Debugging
# # View Dict
# pts_frm_win

# Create DataFrames
pts_drp_frm_win_pos_df = pd.DataFrame(list(pts_frm_win.items()), columns=['Team', 'Points Dropped'])
# pts_frm_win_pos_df

"""#####**MOST PTS DROPPED FROM WINNING POSITIONS**"""

pts_drp_frm_win_pos_df.sort_values(by='Points Dropped', ascending=False).reset_index(drop=True)

"""## **MORE DATA NEEDED**

###**RELEGATION TREND**
"""



"""### **TEAM RATINGS IN THE NWFL**"""



"""### **SCORING CHANCES (A1,B1,A2,B2,A3+ & B3+) --- USE DATA FROM 2018 TILL DATE**"""





"""### **HOW HARD IS IT TO WIN A GAME IN THE NWFL?**"""



"""### **POINTS WON FROM LOSING POSITIONS**"""



"""### **POINTS DROPPED FROM WINNING POSITIONS**"""



"""### **DASHBOARD**"""



"""### **TEAM RATINGS**"""



"""### **TEAM IN FOCUS: EDO QUEENS**"""



"""### **TEAM IN FOCUS: DELTA QUEENS**"""

