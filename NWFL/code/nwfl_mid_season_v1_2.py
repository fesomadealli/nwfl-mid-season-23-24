# -*- coding: utf-8 -*-
"""plottable-projects.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18QNAoif_4dhmfdjV23V3S4b-dOC9Vb0b

## **MOUNT GDRIVE**
"""

from google.colab import drive
drive.mount('/content/drive')

"""

























## **IMPORTS AND LIBRARY INSTALLATIONS**"""

import matplotlib.font_manager as fm
import matplotlib as mpl
import re

# Register the Oswald font
# fm.fontManager.addfont('/content/drive/MyDrive/NWFL/fonts/Oswald-Bold.ttf')
# fm.fontManager.addfont('/content/drive/MyDrive/NWFL/fonts/Oswald-Light.ttf')
#fm.fontManager.addfont('/content/drive/MyDrive/NWFL/fonts/Oswald-Regular.ttf')
# fm.fontManager.addfont('/content/drive/MyDrive/NWFL/fonts/Anton-Regular.ttf')
# fm.fontManager.addfont('/content/drive/MyDrive/NWFL/fonts/Futura-Bold.ttf')
# fm.fontManager.addfont('/content/drive/MyDrive/NWFL/fonts/Futura-Light-font.ttf')

# Specify the font family and size
#font = {'family': 'Oswald',
#       'size': 12}

# Update the default font settings
#mpl.rc('font', **font)

pip install plottable

pip install  highlight_text

# from google.colab import drive
# drive.mount('/content/drive')

# Plottable Table Tool
from plottable import Table

# General Data Analytics Libraries
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

# Text Customization & Fancy Legend Library
import matplotlib.patheffects as path_effects
from matplotlib.patheffects import withStroke
import highlight_text
h_axs = highlight_text.ax_text
h_fig = highlight_text.fig_text

"""##**NOTEBOOK FUNCTIONALITIES**"""

# Run Multiple Commands In Single Cell
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = "all"
# Show All Columns
pd.set_option('display.max_columns', None)

"""## **PLOT ELEMENTS**"""

df23_season = '2022/23'
df24_season = '2023/24'
author = '@fesomadealli'

# Font
b_font =  'Merriweather'
t_font = 'Fira Code'
b_fsize = 14
t_fsize = 16

# Colors for Dark Mode
facecolor = '#242526' #18191A is an alternative choice
ax_color = '#3A3B3C'
plot_color = '#E0CB8A'
off_white = '#FAF9F6'
alt_color = '#303233'

# Figure Paddings
pad_top = "\n\n"
pad_end = "\n\n"
hspace  = " "
vspace  = " "
newline = '\n'

"""## **LOAD NWFL DATASETS**"""

mid_2223 = pd.read_csv('/content/drive/MyDrive/NWFL/csv/NWFL_MID_SEASON_2022_23.csv')
mid_2324 = pd.read_csv('/content/drive/MyDrive/NWFL/csv/NWFL_MID_SEASON_2023_24.csv')

#mid_2324 = pd.read_excel('/content/NWFL_MID_SEASON_2023_24.xlsx')
#mid_2223 = pd.read_excel('/content/NWFL_MID_SEASON_2022_23.xlsx')

mid_2324.info()

"""## **SUMMARRY STATISTICS**

### **2022/23**
"""

mid_2223.describe()

mid_2223.info()

"""### **2023/24**"""

mid_2324.describe()

mid_2324.info()

"""## **FUNCTIONS**"""

def common_scoreline(df=None, period='FTR', viz_type='Probabilities'):
    # Total Number of Games
    num_of_gms = len(df)

    # cols to fetch data
    if period.upper() == 'HTR':
       col_home = 'HTHG'
       col_away = 'HTAG'
    elif period.upper() == 'SHR':
       col_home = 'SHHG'
       col_away = 'SHAG'
    else:
       col_home = 'FTHG'
       col_away = 'FTAG'

    h_teams = df[ f'{col_home}']
    a_teams = df[ f'{col_away}']

    # Get the maximum values of FTTG and FTOG
    max_home_goals = max(df[f'{col_home}'])
    max_away_goals = max(df[f'{col_away}'])

    # Get Threshold for Text Label Color
    threshold_df = df[[f'{col_home}', f'{col_away}']].value_counts().reset_index()


    # Create the figure
    fig, ax = plt.subplots(1,1, figsize=(10, 6), facecolor='white')
    ax.set_facecolor('white')
    # Create a 2D histogram
    heatmap, xedges, yedges = np.histogram2d(h_teams, a_teams,
                                              bins=(np.arange(max_home_goals + 2), np.arange(max_away_goals + 2)))

    # Define a custom colormap with darkgreen
    cmap = plt.get_cmap('Greens')#.copy()
    #cmap.set_under(color=ax_color)

    # ax tick text colors
    ax.tick_params(axis='both', colors="black")
    hide_spines(axes=ax, which_spine="all")

    # Plot the heatmap
    plt.imshow(heatmap.T, cmap=cmap, vmin=0, vmax=np.max(heatmap), origin='lower', interpolation='none')

    # Set xticks and yticks to match the range of possible scorelines
    plt.xticks(np.arange(max_home_goals + 1))
    plt.yticks(np.arange(max_away_goals + 1))

    # Show the colorbar with reversed intensity
    cbar = plt.colorbar(label='Frequency', orientation='vertical', extend='max')

    # Set text properties for colorbar labels
    cbar.ax.set_ylabel('Num of Matches', rotation=270, labelpad=20,
                        fontsize=12, color="#588B8B")

    cbar.ax.tick_params(axis='y', color="#588B8B")
    cbar_spines = ['top','bottom','left','right']
    for spine in cbar_spines:
        cbar.ax.spines[spine].set_visible(False)

    # Geting the cbar ticks
    tick_values = cbar.get_ticks()
    # Threshold for adjusting text color based on intensity of cell
    threshold = int(max(tick_values)/2)

    # Print the frequency on top of each cell
    for i in range(len(xedges) - 1):
        for j in range(len(yedges) - 1):
            if len(df[(df[f'{col_home}'] == i) & (df[f'{col_away}'] == j)]) < threshold:
                cnt_color = 'black'
            else:
                cnt_color = off_white
            if heatmap[i, j] != 0:
                # Expressing Results in Percentages Instead of the Num of Games for eachresult
                pct = (int(heatmap[i, j])/num_of_gms)*100
                # Expressing Results in Probabilities Instead of the Num of Games for eachresult
                prob = pct/100
                # Deciding Output
                if viz_type.lower() == 'probabilities':
                   match_cnt = ax.text(i+0.03, j+0.03, '{0:.2f}'.format(prob), color=cnt_color,
                                    ha='center', va='center', fontsize=14, fontweight='bold')
                   match_cnt.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                                                path_effects.Normal()])

                elif viz_type.lower() == 'percentages':
                  # Printing Values
                  match_cnt = ax.text(i+0.03, j+0.03, '{0:.2f}'.format(pct), color=cnt_color,
                                      ha='center', va='center', fontsize=14, fontweight='bold')
                  match_cnt.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
                                                  path_effects.Normal()])

    # Add labels and title
    # _ylabel = 'Away Team Goals'
    # _xlabel = 'Home Team Goals'

    # title_text = (f'PROB. DISTRIBUTION OF FULL TIME RESULTS \n{df24_season.upper()} NWFL MID SEASON')

    # ANNOTATIONS
    # ylabel Text
    #ylabel_text= fig.text(x=0.02, y= .50, s=_ylabel, ha='center', va='center', rotation=90,
    #                      linespacing=2.2, color=off_white, fontweight='semibold', fontsize=12, zorder=2)
    #ylabel_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
    #                        path_effects.Normal()])

    # xlabel Text
    #xlabel_text= fig.text(x=.45, y=0, s=_xlabel, ha='center', va='center', linespacing=2.2, color=off_white, fontweight='semibold', fontsize=12, zorder=2)
    #xlabel_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
    #                        path_effects.Normal()])

    # Title Text
    #title = fig.text(x=0.48, y=1.0, s=title_text, ha='center', va='center', linespacing=2.2, color=off_white, fontweight='semibold', fontsize=14, zorder=2)
    #title.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
    #                        path_effects.Normal()])


    #  Name Text
    #name_text = fig.text(x=0.45, y=-.22, s=author, ha='center', va='center', color=plot_color, alpha=.3, fontsize=12, zorder=2)
    #name_text.set_path_effects([path_effects.Stroke(linewidth=.005, foreground=off_white),
    #                            path_effects.Normal()])

    # Pad Top
    #fig.text(x=0.5, y= 0.01, s=pad_top, color=off_white, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
    # Pad Bottom
    #fig.text(x=0.5, y= -.25, s=pad_end, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
    ## Pad left
    #fig.text(x=-.15, y= 1.15, s=hspace, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
    # Pad Right
    #fig.text(x=1.06, y=0, s=hspace, color=facecolor, linespacing= 2, ha='center', va='center', fontsize=b_fsize, zorder=2)
    # Save Figure
    # plt.savefig("/content/drive/MyDrive/NWFL/plots/prob_ft_scores_23_24_mid_nwfl.png", dpi=100)
    plt.show();

# Extract goal_info
def extract_numbers(goal_string):
  """
  Returns a List of integers
  Targeted at Performing Goal Difference Analyses
  For extracting the time when the goals were scored by the teams
  It is expected that there are no null values so all null values are expected to have been handled
  """
  # Extract strings enclosed in () and remove non-numeric characters except commas and plus
  matches = re.findall(r'\(([^)]+)\)', goal_string)
  processed_matches = []
  for match in matches:
      numeric_part = re.sub(r'[^0-9\+\,]+', '', match)
      for sub_match in numeric_part.split(','):
        # replace 'a+b' with the sum of a and b
          if '+' in sub_match:
              a, b = sub_match.split('+')
              sub_match = str(int(a) + int(b))
          processed_matches.append(sub_match)
  return processed_matches

def goals_agg(df):
    # Counting Home Games Played Per Team
    home = df['Home Team'].value_counts().reset_index()
    # Renaming Columns
    home.rename(columns={'index': 'Home Team', 'Home Team': 'MP'}, inplace=True)

    # Counting Away Games Played Per Team
    away = df['Away Team'].value_counts().reset_index()
    # Renaming Columns
    away.rename(columns={'index': 'Away Team', 'Away Team': 'MP'}, inplace=True)

    # GroupBy Home
    hgoals_df = df.groupby('Home Team')['HTHG', 'HTAG', 'SHHG', 'SHAG', 'FTHG', 'FTAG'].sum().reset_index()
    # Renaming Columns
    hgoals_df.rename(columns={'HTHG': 'HTGF', 'HTAG': 'HTGA', 'SHHG': 'SHGF', 'SHAG': 'SHGA', 'FTHG': 'FTGF', 'FTAG': 'FTGA'}, inplace=True)
    # Calculate the Average Goals
    hgoals_mean = df.groupby('Home Team')['HTHG', 'HTAG', 'SHHG', 'SHAG', 'FTHG', 'FTAG'].mean().round(2).reset_index()
    hgoals_mean.rename(columns={'HTHG': 'HTGF_Avg', 'HTAG': 'HTGA_Avg', 'SHHG': 'SHGF_Avg', 'SHAG': 'SHGA_Avg', 'FTHG': 'FTGF_Avg', 'FTAG': 'FTGA_Avg'}, inplace=True)
    # Merge DataFrames on the common column
    hgoals = pd.merge(hgoals_df, hgoals_mean, on='Home Team')
    # Add Number of Games Played Per Team
    hgoals = pd.merge(hgoals, home, on='Home Team')
    # Reorder 'MP' Column By Insertion
    home_mp = hgoals['MP']
    hgoals = hgoals.drop(columns=['MP'])
    hgoals.insert(loc=1, column='MP', value=home_mp)

    #  GroupBy Away
    agoals_df = df.groupby('Away Team')['HTHG', 'HTAG', 'SHHG', 'SHAG', 'FTHG', 'FTAG'].sum().reset_index()
    # Renaming Column Headers
    agoals_df.rename(columns={'HTHG': 'HTGA', 'HTAG': 'HTGF', 'SHHG': 'SHGA', 'SHAG': 'SHGF', 'FTHG': 'FTGA', 'FTAG': 'FTGF'}, inplace=True)
    # Calculate the Average Goals
    agoals_mean = df.groupby('Away Team')['HTHG', 'HTAG', 'SHHG', 'SHAG', 'FTHG', 'FTAG'].mean().round(2).reset_index()
    agoals_mean.rename(columns={'HTHG': 'HTGA_Avg', 'HTAG': 'HTGF_Avg', 'SHHG': 'SHGA_Avg', 'SHAG': 'SHGF_Avg', 'FTHG': 'FTGA_Avg', 'FTAG': 'FTGF_Avg'}, inplace=True)
    # Merge DataFrames on the common column
    agoals = pd.merge(agoals_df, agoals_mean, on='Away Team')
    # Add Number of Games Played Per Team
    agoals = pd.merge(agoals, away, on='Away Team')
    # Reorder 'MP' Column By Insertion
    away_mp = agoals['MP']
    agoals = agoals.drop(columns=['MP'])
    agoals.insert(loc=1, column='MP', value=away_mp)

    list_of_teams = df['Home Team'].unique()
    for team in list_of_teams:
      team.strip()
    list_of_teams = sorted(set(list_of_teams))

    # Combined Goals Table
    gls_df = pd.DataFrame({
                    'Teams' : list_of_teams,
                       'MP' : hgoals.MP + agoals.MP,
                'HT_GlsFor' : hgoals.HTGF + agoals.HTGF,
            'HT_GlsAllowed' : hgoals.HTGA + agoals.HTGA,
                'SH_GlsFor' : hgoals.SHGF + agoals.SHGF,
            'SH_GlsAllowed' : hgoals.SHGA + agoals.SHGA,
                'FT_GlsFor' : hgoals.FTGF + agoals.FTGF,
            'FT_GlsAllowed' : hgoals.FTGA + agoals.FTGA,
    })

    # Goal Difference
    gls_df['HT_GlsDiff'] = gls_df.HT_GlsFor - gls_df.HT_GlsAllowed
    gls_df['SH_GlsDiff'] = gls_df.SH_GlsFor - gls_df.SH_GlsAllowed
    gls_df['FT_GlsDiff'] = gls_df.FT_GlsFor - gls_df.FT_GlsAllowed

    # Goal Averages
    gls_df['HT_GF_Avg'] = (gls_df.HT_GlsFor/gls_df.MP).round(2)
    gls_df['HT_GA_Avg'] = (gls_df.HT_GlsAllowed/gls_df.MP).round(2)
    gls_df['SH_GF_Avg'] = (gls_df.SH_GlsFor/gls_df.MP).round(2)
    gls_df['SH_GA_Avg'] = (gls_df.SH_GlsAllowed/gls_df.MP).round(2)
    gls_df['FT_GF_Avg'] = (gls_df.FT_GlsFor/gls_df.MP).round(2)
    gls_df['FT_GA_Avg'] = (gls_df.FT_GlsAllowed/gls_df.MP).round(2)

    # View Home Goals df
    return hgoals, agoals, gls_df

def show_all_cells(bool_cmd=True):
  """
  A function that displays all cells in dataframe. Please note, that this is not always advisable and isn't ideal for large datasets
  bool_cmd : (default=False) The boolean parameter that controls if the complete dataframe should be displayed or not
  """
  import pandas as pd
  if bool_cmd is True:
      # Set options to display all rows and columns
      pd.set_option('display.max_rows', None)
      pd.set_option('display.max_columns', None)
  else:
      # Reset options to default (if needed)
      pd.reset_option('display.max_rows')
      pd.reset_option('display.max_columns')

# Hide Spines
def hide_spines(axes, which_spine):
    spines = ['top', 'bottom', 'left', 'right']
    error_msg = (f"Invalid spine selection: '{which_spine}'. Please select from: {spines}")

    if which_spine != 'all':
        if type(which_spine) == list:
            for i in range(len(which_spine)):
                spine = which_spine[i]
                if spine in spines:
                    # Hide the enlisted spines
                    axes.spines[spine].set_visible(False)
                else:
                    return(error_msg)

        elif type(which_spine) == str:
            if which_spine in spines:
                axes.spines[which_spine].set_visible(False)
            else:
                return(error_msg)
    else:
        # Hide all spines
        for spine in range(len(spines)):
            axes.spines[spines[spine]].set_visible(False)

def remove_whitespaces_from_df(df):
      # prepare the error message
      error_msg = "Expected DataFrame but got {}".format(str(type(df)).split("'")[1])
      # Writing the Main Function
      def main(df):
          """
          This function does the cleaning in itself
          df: (DataFrame Object) This is the Dataframe to be eventually cleaned
          """
          # Remove whitespaces from Column Names
          df.columns = [col.strip() for col in df.columns]
          # Remove Leading & Trailing Whitespaces from all rows using Vectorization
          df = df.apply(lambda x: x.str.strip() if x.dtype == "object" else x)
          return df

      # check function parameters
      if type(df) is list:
          # Initislize a List for holding the cleaned versions of the dfs
          cleaned_dfs = []
          # iterate over the dfs to be cleaned
          for dataframe in df:
              if type(dataframe) is pd.core.frame.DataFrame:
                  dataframe = main(dataframe)
                  cleaned_dfs.append(dataframe)
              else:
                  raise TypeError(error_msg)
          # Return list of cleaned dfs
          return cleaned_dfs

      # If cleaning just one df
      elif type(df) is pd.core.frame.DataFrame:
        main(df)
      else:
        raise TypeError(error_msg)
      # Return df
      return df

def calculate_standings(df, game_week=None, group=None):
    """
          df : DataFrame for calculating Standings
    game_week: The Match Week for which the Standings is to be returned
        games: (default='all') The partitioning of the games, whether home games, away games or the combined table
        group: (default=None) The group whose Standings we're interested in.
    """

    # Initialize dictionaries to store team stats
    team_stats = {'MP': {}, 'W': {}, 'D': {}, 'L': {}, 'GF': {}, 'GA': {}, 'GD': {}, 'PTS': {}, 'Group': {}}

    if game_week is not None:
      if type(game_week) is not int:
        return("You didn't enter a correct game week: expected int but got {}".format(type(game_week))), team_stats
      else:
        # Filter DataFrame for the specified match week
        filtered_df = df.loc[df['Game Week'] <= game_week]
    else:
        # Filter DataFrame for the specified match week
        filtered_df = df

    # Iterate through the filtered dataset
    for row_index, match in filtered_df.iterrows():
        home_team, away_team, hteam_gls, ateam_gls, result = match['Home Team'], match['Away Team'], match['FTHG'], match['FTAG'], match['FTR']
        hteam_grp = ateam_grp = match['Group']

        # Initialize team stats if not already in the dictionaries (This is a great assist by Chat-GPT)
        for stat in team_stats:
            team_stats[stat].setdefault(home_team, 0)
            team_stats[stat].setdefault(away_team, 0)

        # Update stats based on match result
        if result == 'H':
            team_stats['PTS'][home_team] += 3
            team_stats['W'][home_team] += 1
            team_stats['L'][away_team] += 1
        elif result == 'D':
            team_stats['PTS'][home_team] += 1
            team_stats['PTS'][away_team] += 1
            team_stats['D'][home_team] += 1
            team_stats['D'][away_team] += 1
        elif result == 'A':
            team_stats['PTS'][away_team] += 3
            team_stats['W'][away_team] += 1
            team_stats['L'][home_team] += 1

        # Update goals for and against
        team_stats['GF'][home_team] += hteam_gls
        team_stats['GA'][home_team] += ateam_gls
        team_stats['GF'][away_team] += ateam_gls
        team_stats['GA'][away_team] += hteam_gls

        # Update goal difference
        team_stats['GD'][home_team] = team_stats['GF'][home_team] - team_stats['GA'][home_team]
        team_stats['GD'][away_team] = team_stats['GF'][away_team] - team_stats['GA'][away_team]

        # Matches Played
        team_stats['MP'][home_team] += 1
        team_stats['MP'][away_team] += 1

        # Update Group Information
        team_stats['Group'][home_team] = hteam_grp
        team_stats['Group'][away_team] = ateam_grp

    # Create a DataFrame for standings
    standings_df = pd.DataFrame(team_stats)
    # Printing the dataframe
    standings_df.reset_index(level=0, inplace=True)

    # Ading & Reorder 'Teams' Column By Insertion
    teams = standings_df['index']
    standings_df = standings_df.drop(columns=['index'])
    standings_df.insert(loc=0, column='Teams', value=teams)

    # Sort standings by PTS in descending order
    standings_df = standings_df.rename(columns={'index': 'Team'})
    standings_df = standings_df.sort_values(by=['PTS', 'GD', 'GF', 'GA', 'Teams'], ascending=([False]*4 + [True])).reset_index()
    standings_df = standings_df.drop(['index'], axis=1)

    #  Return Dataframe per group based on user specificaton
    if group is not None and group.upper() in ['A','B']:
      standings_df = standings_df.loc[standings_df.Group == group.upper()]
      # Reset the index of the subset DataFrame
      standings_df = standings_df.reset_index(drop=True)
    else:
      return("Invalid Group Selection: The abridged 2023/24 NWFL season only had Groups A and B"), team_stats

    return standings_df, team_stats

def league_pos_across_gw(df, gw, group):
    # Getting the teams
    GrpA = sorted(list(df.loc[df['Group'] == 'A']['Home Team'].unique()))
    GrpB = sorted(list(df.loc[df['Group'] == 'B']['Home Team'].unique()))

    # Getting teams in their drawn groups
    teams = GrpA if group.upper() == 'A' else GrpB if group.upper() == 'B' else None

    # Create an empty DataFrame to store the standings for each match week
    standings_by_week = pd.DataFrame(index=range(1, gw+1))

    # Iterate through each team to calculate standings for each match week
    for team in teams:
        team_standings = []
        for week in range(1, gw+1):
            standings_df, _ = calculate_standings(df=df, game_week=week, group=group)
            # display(standings_df.head())
            # Get the position of the team for the current match week
            position = standings_df[standings_df['Teams'] == team].index[0] + 1
            team_standings.append(position)
        # Add the team's standings for each match week to the DataFrame
        standings_by_week[team] = team_standings

    # Transposing the standings for better visual
    teams_pos_perwk = standings_by_week.T
    teams_pos_perwk = teams_pos_perwk.replace({1:"1st", 2:"2nd", 3:"3rd", 4:"4th",
                                               5:"5th", 6:"6th", 7:"7th", 8:"8th"})
    # Modifying column headers to reflect GWX where X is Game Week
    teams_pos_perwk.columns = [f'GW{str(col)}' for col in teams_pos_perwk.columns]
    # print(teams_pos_perwk)

    # Create a line plot
    plt.figure(figsize=(8, 6))
    plt.ylim(8.5,0.5)

    for team in teams:
        plt.plot(standings_by_week.index, standings_by_week[team], label=team)

    plt.title('Team Standings Over Match Weeks')
    plt.xlabel('Match Week')
    plt.ylabel('League Position')
    # Place the legend to the right of the plot
    plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
    plt.grid(alpha=.25)
    plt.show();
    # Save figure
    plt.savefig("/content/drive/MyDrive/NWFL/plots/23_24_nwfl_league_pos_in_grp_{}_across_{}_gm_wks".format(group,str(gw)), dpi=100)
    #  Save the dataframe
    return teams_pos_perwk

def goalscorers_df(df):
    import re

    # Initialize the main dictionary
    main_dict = {}

    # Step 1: Collect unique seasons
    unique_seasons = df['Season'].unique()
    # print("Seasons: ", unique_seasons)

    # Step 2-8: Process HomeTeam Goals and AwayTeam Goals columns
    for season in unique_seasons:
        # Step 2: Initialize season dictionary
        season_dict = {}

        # Step 3-8: Process HomeTeam Goals and AwayTeam Goals columns
        for team_goals_column in ['HomeTeam Goals', 'AwayTeam Goals']:
            # Determine the team name column based on the current processing column
            team_name_column = 'Home Team' if team_goals_column == 'HomeTeam Goals' else 'Away Team'

            # Extract player and team information using the modified regex function
            def extract_info(row):  # row is a single row dataframe
                team_goals = row[team_goals_column]
                if pd.notna(team_goals):
                    # Remove non-alphanumeric characters and emojis
                    matches = re.sub(r'(?![\(\)\[\],\n])[^\w\s\n+]+', '', team_goals)
                    # print(matches)
                    # Split the string by newline character
                    goals = matches.split('\n')
                    # print(goals)
                    for goalscorer_info in goals:
                        matches = re.findall(r'([^\(]+)\s*\(([^)]+)\)', goalscorer_info)
                        # print(matches)
                        for match in matches:
                            player_name = match[0].strip()
                            goal_details = match[1].replace(" ", "")
                            # print(player_name, ":", goal_details,"\n")

                            # Step 4-8: Update the complex data structure
                            player_dict = season_dict.setdefault(player_name, {})
                            team_name = row[team_name_column]
                            team_dict = player_dict.setdefault(team_name, {})
                            date_str = str(row['Date']).split()[0] if pd.notna(row['Date']) else '00/00/0000'
                            date_dict = team_dict.setdefault(date_str, {})

                            # Step 5-8: Update values
                            date_dict['Team Faced'] = row['Away Team'] if team_goals_column == 'HomeTeam Goals' else row['Home Team']
                            date_dict['Goals Scored'] = len(goal_details.split(","))
                            date_dict['Goal Time'] = goal_details

            # Apply the extract_info function to the DataFrame
            df.apply(extract_info, axis=1)

        # Step 9: Append the season dictionary to the main dictionary
        main_dict[season] = season_dict

    # print(main_dict);

    # # Step 10: Convert the complex data structure into a DataFrame
    data = []
    for season, season_dict in main_dict.items():
        for player_name, player_dict in season_dict.items():
            for team_name, team_dict in player_dict.items():
                for date_str, date_dict in team_dict.items():
                    row = {'Season': season, 'Player Name': player_name, 'Team Name': team_name, 'Date': date_str}
                    row.update(date_dict);
                    data.append(row);

    # Create DataFrame
    result_df = pd.DataFrame(data);
    return result_df
    # Display the resulting DataFrame
    # print(result_df);

# Define a global _goals variable to collect a dataframe of goal scorers
# that is grouped by the number of goals they scored in a match
# (eg: lone goal[index 0], brace[index 1], hat-trick[index 2], haul[index 3]... etc)
# Note the index
global _goals
_goals = []

def melted_gls_df(df):
    """
    For optimal function and to reduce load on this function, endeavor to remove the rows where only a (one) goal was scored.
    Do this by subsetting the dataframe where one goal was scored and later on you may concatenate that dataframe with the one returned by this function.
    """
    # Get unique values in 'Goals Scored' column
    unique_goals = df['Goals Scored'].unique()
    melted_dfs = []

    # Create separate DataFrames for each unique value in 'Goals Scored'
    for goals in unique_goals:
        # Subset the original DataFrame based on 'Goals Scored'
        subset_df = df[df['Goals Scored'] == goals].copy()

        # Split 'Goal Time' column into multiple columns based on the number of goals
        subset_df[['goal_' + str(i) for i in range(1, goals + 1)]] = subset_df['Goal Time'].str.split(',', expand=True)

        # Melt the DataFrame to create a new row for each goal
        melted_df = pd.melt(subset_df, id_vars=['Season', 'Player Name', 'Team Name', 'Date', 'Team Faced', 'Goals Scored'],
                            value_vars=['goal_' + str(i) for i in range(1, goals + 1)], value_name='Goal Info')

        # Drop unnecessary columns
        melted_df = melted_df.drop(['variable'], axis=1).dropna()
        # Keeping track of all melted dfs
        melted_dfs.append(melted_df)

    # Updat our global _goals df
    _goals = melted_dfs
    # Concatenate all melted DataFrames vertically
    concatenated_df = pd.concat(melted_dfs, ignore_index=True)

    # Display
    concatenated_df['Goals Scored'] = 1
    return concatenated_df

# Function to check for own_goal
def check_own_goal(info):
    """
    To use this function, please use the applymap() method.
    """
    own_goal = "[og]"

    # Convert to lowercase and remove any fullstops
    info_lower = info.lower().replace('.', '')
    # print(info)
    if own_goal in info_lower:
        # print("Own goal found!")
        return int(True)
    else:
        return int(False)

# Function to check for own_goal and penalty
def check_penalty_goals(info):
    """
    To use this function, please use the applymap() method.
    """
    penalty = "[pen]"
    alt_penalty = "[pk]"

    # Convert to lowercase and remove any fullstops
    info_lower = info.lower().replace('.', '')

    if (penalty in info_lower) or (alt_penalty in info_lower):
        # print("Penalty found!")
        return int(True)
    else:
        return int(False)

def time_dist_of_goals(df, dist='goals_for'):
  """
  df : (DataFrame) dataframe to be used
  dist: (String) goals_for or goals_allowed  (default: goals_for)
  """
  import re
  # Extract minute information from Goal Info
  df['Minute'] = df['Goal Info'].str.extract(r'(\d+)').astype(int)
  # Create empty column
  df['group'] = np.nan
  # Assign values to categorize goals based on goal time
  for i, row in df.iterrows():
      if '45+' in row['Goal Info']:
          df.at[i,'group'] = '45+'
      elif '90+' in row['Goal Info']:
          df.at[i,'group'] = '90+'
      else:
          # print(f"Item {row['Goal Info']} at {i} is initially of type; ", type(row['Goal Info']))
          integer_value = int((re.findall(r'(\d+)', str(row['Goal Info'])))[0])
          # print(f"Item {row['Goal Info']} at {i} is now formatted as {integer_value} and of type; ", type(integer_value))
          if integer_value <= 15:
              df.at[i,'group'] = '0-15'
          elif 15 < integer_value <= 30:
              df.at[i,'group'] = '16-30'
          elif 30 < integer_value <= 45:
              df.at[i,'group'] = '31-45'
          elif 45 < integer_value <= 60:
              df.at[i,'group'] = '46-60'
          elif 60 < integer_value <= 75:
              df.at[i,'group'] = '61-75'
          elif 75 < integer_value <= 90:
              df.at[i,'group'] = '76-90'

  # Format the 'group' column as category
  df['group'] = df['group'].astype('category')
  # Drop the 'Goal Info' column
  df.drop('Goal Info', axis=1, inplace=True)

  if dist is "goals_for":
    col = "Team Name"
  else:
    col = 'Team Faced'

  # Create a new DataFrame 'new_df' with columns: 'Team' and categories from 'group'
  new_df = pd.DataFrame({'Team': df['{}'.format(col)]})
  # Get unique categories from 'group' column
  categories = df['group'].cat.categories
  # Sort the categories alphabetically
  categories = sorted(categories)

  # Add columns for each category in 'new_df'
  for category in categories:
      new_df[category] = 0
  # Count occurrences of each category for each team
  for i, row in df.iterrows():
      team = row['Team']
      category = row['group']
      new_df.at[i, category] = new_df.at[i, category] + 1

  # Convert all columns except 'Team' to integers
  new_df.iloc[:, 1:] = new_df.iloc[:, 1:].astype(int)
  # Perform groupby operation on 'Team' and sum the values across other columns
  grouped_df = new_df.groupby('Team').sum()
  # Reset the index
  grouped_df = grouped_df.reset_index()
  # Calculate sum across rows and create 'Sum' column
  grouped_df['Sum'] = grouped_df.iloc[:, 1:].sum(axis=1)
  # Insert 'Sum' column at index 1
  grouped_df.insert(1, 'Goals', grouped_df.pop('Sum'))

  # PLOT THE GOALS TABLE
  fig = plt.figure(figsize=(7,7), dpi=100)
  ax = plt.subplot()

  ncols = len(grouped_df.columns.to_list())
  nrows = grouped_df.shape[0]

  ax.set_xlim(0, ncols + 1)
  ax.set_ylim(0, nrows + .5)

  positions = [0.25, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5]

  # Create column headers
  column_headers = grouped_df.columns.to_list()

  # Add table's main text
  for i in range(nrows):
      for j, column in enumerate(column_headers):
          if j == 0:
              ha = 'left'
          else:
              ha = 'center'
          if column == 'Goals':
            weight = 'bold'
          else:
            weight = 'normal'
          ax.annotate(
              xy=(positions[j], nrows-(0.5*(i + 0.5))),
              text=grouped_df[column].iloc[i],
              ha=ha,
              va='center',
              weight=weight
          )

  # Add column names
  x = grouped_df.columns.to_list()
  # Removing 'Teams' label from the column names
  x[0] = ""
  column_names = x
  for index, c in enumerate(column_names):
          if index == 0:
              ha = 'left'
          else:
              ha = 'center'
          ax.annotate(
              xy=(positions[index], nrows + 0.15),
              text=column_names[index],
              ha=ha,
              va='bottom',
              weight='bold'
          )

  # Add dividing lines
  # Top Line
  ax.plot([ax.get_xlim()[0], ax.get_xlim()[1]], [nrows, nrows], lw=1.5, color='black', marker='', zorder=4)
  # Base Line
  ax.plot([ax.get_xlim()[0], ax.get_xlim()[1]], [0, 0], lw=1.5, color='black', marker='', zorder=4)
  # Line Between Table Items
  for x in range(1, nrows):
      ax.plot([ax.get_xlim()[0], ax.get_xlim()[1]], [nrows-(x*.5), nrows-(x*.5)], lw=1.25, color='gray', ls=':', zorder=3 , marker='')

  # ax.set_axis_off()
  plt.show();
  return grouped_df

"""## **DATA CLEANING AND PREPROCESSING**"""

# Replace The Dataframes with the cleaned one
df_ws = remove_whitespaces_from_df(df=[mid_2223, mid_2324]);
mid_2223 = df_ws[0]
mid_2324 = df_ws[1]

mid_2324.columns.to_list()
mid_2324['Home Team'].unique()
len(mid_2324['Home Team'].unique())

# Renaming Nassarawa to Nasarawa
mid_2324.replace('Nassarawa Amazons', 'Nasarawa Amazons', inplace=True)
mid_2223.replace('Nassarawa Amazons', 'Nasarawa Amazons', inplace=True)

# Copy Dataframes
df23=mid_2223.copy()
df24=mid_2324.copy()

print("22/23 SEASON DATA:\n{}\n{}\n\n 23/24 SEASON DATA:\n{}\n{}".format(df23.shape, df23.columns, df24.shape, df24.columns))

"""### **NWFL 2022/23 MID-SEASON**"""

# Reduce Range of Data
df23 = df23.drop(df23.loc[:,'HomeTeam XI':'Penalties'].columns, axis = 1)

# View Dataframe
df23.head(3)

# Second Half Home Goals
df23['SHHG'] = df23.FTHG - df23.HTHG
df23['SHAG'] = df23.FTAG - df23.HTAG

#  View Dataframe
df23.sample(5)

# Reorder 'SHAG' Column By Insertion
shag = df23['SHAG']
df23 = df23.drop(columns=['SHAG'])
df23.insert(loc=11, column='SHAG', value=shag)

# Reorder 'SHHG' Column By Insertion
shhg = df23['SHHG']
df23 = df23.drop(columns=['SHHG'])
df23.insert(loc=12, column='SHHG', value=shhg)

#  View Dataframe
df23.head(2)

df23.info()

#  Converting Column Type(s)
df23['Notes'] = df23['Notes'].astype('str')
# df23[['HTHG', 'HTAG', 'SHHG', 'SHAG']] = df23[['HTHG', 'HTAG', 'SHHG', 'SHAG']].astype('int64')       # won't work without removing null values

"""### **NWFL 2023/24 MID-SEASON**"""

# Reduce Range of Data
df24 = df24.drop(df24.loc[:,'HomeTeam XI':'Penalties'].columns, axis = 1)
# View Dataframe
df24.head(2)

# Second Half Home Goals
df24['SHHG'] = df24.FTHG - df24.HTHG
df24['SHAG'] = df24.FTAG - df24.HTAG
#  View Dataframe
df24.head(2)

# Reorder 'SHAG' Column By Insertion
shag = df24['SHAG']
df24 = df24.drop(columns=['SHAG'])
df24.insert(loc=11, column='SHAG', value=shag)

# Reorder 'SHHG' Column By Insertion
shhg = df24['SHHG']
df24 = df24.drop(columns=['SHHG'])
df24.insert(loc=12, column='SHHG', value=shhg)

# View Dataframe
df24.head(3)

"""## **DATA TORCHLIGHTING**

### **2023/24 NWFL TEAMS**
"""

GrpA = sorted(list(df24.loc[df24['Group'] == 'A']['Home Team'].unique()))
GrpA

GrpB = sorted(list(df24.loc[df24['Group'] == 'B']['Home Team'].unique()))
GrpB

# Combined list of teams
list_of_teams = sorted(GrpA + GrpB)

# Display the result
type(list_of_teams)
print(list_of_teams)
len(list_of_teams)

"""###**2022/23 TEAMS**"""

GrpA23 = sorted(list(df23.loc[df23['Group'] == 'A']['Home Team'].unique()))
GrpB23 = sorted(list(df23.loc[df23['Group'] == 'B']['Home Team'].unique()))
list_of_teams23 = sorted(GrpA23 + GrpB23)

print(GrpA23)
print(GrpB23)
list_of_teams23

"""###**HOME & AWAY WIN PCTGS**

####**Note on value_counts()**

When using reset_index(), the existing index becomes a new column, and if a column with the same name already exists, it will raise an error.

To gain better control over this process, you can specify the name of the new column for the index when using reset_index(). Here's an example:



```
df24.groupby('Away Team')['FTR'].value_counts().reset_index(name='count')
```



If you want to rename the 'FTR' column before using reset_index(), you can do it like this:

```
df24.groupby('Away Team')['FTR'].value_counts().rename('my_count').reset_index()
```

####**HOME GAMES**
"""

home = df24.groupby('Home Team')['FTR'].value_counts().rename('Games').reset_index()
# Modify the FTR column
home['FTR'] = home['FTR'].replace({'A': 'L', 'H': 'W'})

# home

# Assuming your original DataFrame is named df
# Create a new DataFrame with the desired columns
home_standings = pd.DataFrame(columns=['Team', 'MP', 'Wins', 'Draws', 'Losses', 'Win_Pct'])

# Extract unique teams from the 'Home Team' column
teams = home['Home Team'].unique()

# Iterate over each team to calculate wins, draws, losses, and win percentage
for team in teams:
    team_data = {
        'Team': team,
        'MP': 0,
        'Wins': 0,
        'Draws': 0,
        'Losses': 0,
        'Win_Pct': 0.0
    }

    # Filter rows for the current team where they played at home
    team_home_games = home[home['Home Team'] == team]

    # Update team_data based on FTR values
    for _, game in team_home_games.iterrows():
        if game['FTR'] == 'W':
            team_data['Wins'] += int(game['Games'])
        elif game['FTR'] == 'D':
            team_data['Draws'] += int(game['Games'])
        elif game['FTR'] == 'L':
            team_data['Losses'] += int(game['Games'])
        # Calculate Games plaayed
        team_data['MP'] = int(team_data['Wins'] + team_data['Draws'] + team_data['Losses'])

    # Calculate Win_Pct
    total_games = team_data['Wins'] + team_data['Draws'] + team_data['Losses']
    if total_games > 0:
        team_data['Win_Pct'] = round((team_data['Wins'] / total_games) * 100, 2)

    # Append team_data to the home_standings DataFrame
    home_standings = home_standings.append(team_data, ignore_index=True)

# Display the result
home_standings

"""####**AWAY TEAMS**"""

away = df24.groupby('Away Team')['FTR'].value_counts().reset_index(name='Games')
# Modify the FTR column
away['FTR'] = away['FTR'].replace({'A': 'W', 'H': 'L'})

# Assuming your original DataFrame is named df
# Create a new DataFrame with the desired columns
away_standings = pd.DataFrame(columns=['Team', 'MP', 'Wins', 'Draws', 'Losses', 'Win_Pct'])

# Extract unique teams from the 'away Team' column
teams = away['Away Team'].unique()

# Iterate over each team to calculate wins, draws, losses, and win percentage
for team in teams:
    team_data = {
        'Team': team,
        'MP': 0,
        'Wins': 0,
        'Draws': 0,
        'Losses': 0,
        'Win_Pct': 0.0
    }

    # Filter rows for the current team where they played at away
    team_away_games = away[away['Away Team'] == team]

    # Update team_data based on FTR values
    for _, game in team_away_games.iterrows():
        if game['FTR'] == 'W':
            team_data['Wins'] += int(game['Games'])
        elif game['FTR'] == 'D':
            team_data['Draws'] += int(game['Games'])
        elif game['FTR'] == 'L':
            team_data['Losses'] += int(game['Games'])
        # Calculate Games plaayed
        team_data['MP'] = int(team_data['Wins'] + team_data['Draws'] + team_data['Losses'])

    # Calculate Win_Pct
    total_games = team_data['Wins'] + team_data['Draws'] + team_data['Losses']
    if total_games > 0:
        team_data['Win_Pct'] = round((team_data['Wins'] / total_games) * 100, 2)

    # Append team_data to the away_standings DataFrame
    away_standings = away_standings.append(team_data, ignore_index=True)

# Display the result
away_standings

"""####**COMBINED WIN PCTGS PER VENUE (HOME&AWAY)**


"""

home_standings.columns= ['Team', 'MP_Home', 'Wins_Home', 'Draws_Home', 'Losses_Home', 'Win_Pct_Home']

away_standings.columns= ['Team', 'MP_Away', 'Wins_Away', 'Draws_Away', 'Losses_Away', 'Win_Pct_Away']

win_pct_df = pd.merge(home_standings, away_standings, on='Team')

# create a new column
new_col = win_pct_df.MP_Home + win_pct_df.MP_Away
# Insert the new column at the specified position
index = 1
win_pct_df.insert(index, 'MP', new_col)

# View df
win_pct_df

wpct_grpA = win_pct_df[win_pct_df['Team'].isin(GrpA)]
wpct_grpA

wpct_grpB = win_pct_df[win_pct_df['Team'].isin(GrpB)]
wpct_grpB

"""### **LEAGUE TABLE TREND**

####**2023/24 MID SEASON**
"""

# Mid Season Standings
nwfl24_grpA_gw7, _dict = calculate_standings(df=df24, game_week=7, group='a')
nwfl24_grpA_gw7

# Mid Season Standings
nwfl24_grpB_gw7, _dict = calculate_standings(df=df24, game_week=7, group='b')
nwfl24_grpB_gw7

league_pos_across_gw(df=df24, gw=7, group='a')

league_pos_across_gw(df=df24, gw=7, group='b')

"""####**2022/23 MID SEASON TREND**"""

# Mid Season Standings
nwfl23_grpA_gw7, _dict = calculate_standings(df=df23, game_week=7, group='a')
nwfl23_grpA_gw7

#league_pos_across_gw(df=df23, gw=7, group='a')

# Mid Season Standings
nwfl23_grpB_gw7, _dict = calculate_standings(df=df23, game_week=7, group='b')
nwfl23_grpB_gw7

#league_pos_across_gw(df=df23, gw=7, group='b')

"""### **COMPARING MID-SEASON SUMMARIES (2022/23 VERSUS 2023/24 SEASON)**"""

# Current Season (2023/24)
print("2023/24 SEASON\n")
df24.describe().round(2)

# Previous Season (2023/24)
print("\n2022/23 SEASON\n")
df23.describe().round(2)

"""## **GOALS ANALYSES**

### **DATA AGGREGATION (GOALS)**

####**GOALS IN GAMES**
"""

gls_gms24 = df24.loc[(df24['FTHG'] != 0) | (df24['FTAG'] != 0)]
print("{} Mid Season: Goals were scored on {} different match days".format(df24_season, len(gls_gms24)))

gls_gms23 = df23.loc[(df23['FTHG'] != 0) | (df23['FTAG'] != 0)]
print("{} Mid Season: Goals were scored on {} different match days".format(df23_season, len(gls_gms23)))

"""####**GOALLESS DRAWS**"""

no_gls_in_gms24 = df24.loc[(df24['FTHG'] == 0) & (df24['FTAG'] == 0)]
print("There were {} goalless draws in {} Mid Season".format(len(no_gls_in_gms24), df24_season))

no_gls_in_gms23 = df23.loc[(df23['FTHG'] == 0) & (df23['FTAG'] == 0)]
print("There were {} goalless draws in {} Mid Season".format(len(no_gls_in_gms23), df23_season))

"""#### **2022/23 SEASON GOALS AGG**"""

hgoals23, agoals23, comb23 = goals_agg(df23)

hgoals23

agoals23

comb23

"""#### **2023/24 SEASON GOALS AGG**"""

hgoals, agoals, gls_df = goals_agg(df24)

# View Home Goals df
hgoals

# View Away Games Goals Table
agoals

# Combined Goals Table
gls_df

"""### **TIME DISTRIBUTION OF GOALS SCORED/CONCEDED**"""

show_all_cells()
goals24 = goalscorers_df(df24)
goals24
# !cp <output-file-name> /content/drive/MyDrive/<destination-folder-name>
# goals24.to_csv(r'/content/drive/MyDrive/NWFL/csv/2023_24_NWFL_MID_SEASON_GOALS.csv')

show_all_cells(False)
goals24['Goals Scored'].sum()
total_goals24 = df24.FTHG.sum() + df24.FTAG.sum()
print(goals24['Goals Scored'].sum() == total_goals24)

goals24['Goals Scored'].value_counts()

# Flatten Goals Dataframe
goals24_mod = melted_gls_df(goals24)
# Check Goal Description
goals24_mod['own_goal'] = goals24_mod[['Goal Info']].applymap(check_own_goal)
goals24_mod['penalty'] = goals24_mod[['Goal Info']].applymap(check_penalty_goals)
# Clean the 'Player Name' column
for i, name in enumerate(goals24_mod['Player Name']):
  goals24_mod['Player Name'][i] = re.sub(r'[^A-Za-z\s]+', '', goals24_mod['Player Name'][i])


# Show all cells
show_all_cells()
# View Dataframe
goals24_mod

# Plot Goals Per Match Time Interval
show_all_cells(False)
time_dist_gls = goals24_mod[['Team Name',   'Team Faced', 'Goal Info']]
time_dist_gls

def time_dist_of_goals(df=time_dist_gls, dist="goals_for"):

    import re

    # Extract minute information from Goal Info
    df['Minute'] = df['Goal Info'].str.extract(r'(\d+)').astype(int)
    # Create empty column
    df['group'] = np.nan
    # Assign values to categorize goals based on goal time
    for i, row in df.iterrows():
        if '45+' in row['Goal Info']:
            df.at[i,'group'] = '45+'
        elif '90+' in row['Goal Info']:
            df.at[i,'group'] = '90+'
        else:
            integer_value = int((re.findall(r'(\d+)', str(row['Goal Info'])))[0])
            if integer_value <= 15:
                df.at[i,'group'] = '0-15'
            elif 15 < integer_value <= 30:
                df.at[i,'group'] = '16-30'
            elif 30 < integer_value <= 45:
                df.at[i,'group'] = '31-45'
            elif 45 < integer_value <= 60:
                df.at[i,'group'] = '46-60'
            elif 60 < integer_value <= 75:
                df.at[i,'group'] = '61-75'
            elif 75 < integer_value <= 90:
                df.at[i,'group'] = '76-90'
            elif 90 < integer_value:
                df.at[i,'group'] = '90+'

    # Format the 'group' column as category
    df['group'] = df['group'].astype('category')
    # Drop the 'Goal Info' column
    df.drop('Goal Info', axis=1)#, inplace=True)

    # Deciding columns to be used in case we want to show when teams are conceding
    if dist == "goals_for":
      col = "Team Name"
    elif dist == "goals_allowed":
      col = 'Team Faced'

    # Create a new DataFrame 'new_df' with columns: 'Team' and categories from 'group'
    new_df = pd.DataFrame({'Team': df['{}'.format(col)]})
    # Get unique categories from 'group' column
    categories = df['group'].cat.categories
    # Sort the categories alphabetically
    categories = sorted(categories)

    # Add columns for each category in 'new_df'
    for category in categories:
        new_df[category] = 0

    # Count occurrences of each category for each team
    for i, row in df.iterrows():
        team = row[f'{col}']
        category = row['group']
        new_df.at[i, category] = new_df.at[i, category] + 1
    # Convert all columns except 'Team' to integers
    new_df.iloc[:, 1:] = new_df.iloc[:, 1:].astype(int)

    # Perform groupby operation on 'Team' and sum the values across other columns
    grouped_df = new_df.groupby('Team').sum()
    # Reset the index
    grouped_df = grouped_df.reset_index()
    # Calculate sum across rows and create 'Sum' column
    grouped_df['Sum'] = grouped_df.iloc[:, 1:].sum(axis=1)
    # Insert 'Sum' column at index 1
    grouped_df.insert(1, 'Goals', grouped_df.pop('Sum'))


    # MAKING THE PLOT
    fig = plt.figure(figsize=(10,10), dpi=100)
    ax = plt.subplot()

    ncols = len(grouped_df.columns.to_list())
    nrows = grouped_df.shape[0]

    ax.set_xlim(-1, ncols + 15)
    ax.set_ylim(-1, nrows + .5)

    ax.set_axis_off()

    # column positions
    gls_col_pos = 7.00
    x_pos = gls_col_pos + 1.75
    positions = [0.25, gls_col_pos, x_pos+(1*1.75), x_pos+(2*1.75), x_pos+(3*1.75), x_pos+(4*1.75),
                x_pos+(5*1.75), x_pos+(6*1.75), x_pos+(7*1.75), x_pos+(8*1.75)]

    # Create column headers
    column_headers = grouped_df.columns.to_list()

    # Add table's main text
    for i in range(nrows):
        for j, column in enumerate(column_headers):
            if j == 0:
                ha = 'left'
                j_pos = positions[j]+0.5
            else:
                j_pos = positions[j]
                ha = 'center'
            if column == 'Goals':
              weight = 'normal'
              color = "black"
            else:
              weight = 'normal'
            if str(grouped_df[column].iloc[i]) == "0":
              color = "gray"
            else:
              color = "blue"
            if str(grouped_df[column].iloc[i]) in list_of_teams:
              color = 'black'
              size = 15

            ax.annotate(
                xy=(j_pos, nrows-(i + 0.75)),
                text=grouped_df[column].iloc[i],
                ha=ha,
                va='center',
                weight=weight,
                color=color
            )

    # Add column names
    x = grouped_df.columns.to_list()
    # Removing 'Teams' label from the column names
    x[0] = ""
    column_names = x
    for index, c in enumerate(column_names):
            if index == 0:
                ha = 'left'
            else:
                ha = 'center'
            ax.annotate(
                xy=(positions[index], nrows+0.5),
                text=column_names[index],
                ha=ha,
                va='bottom',
                weight='normal'
            )

    # Add dividing lines
    # Top Line
    ax.plot([ax.get_xlim()[0], ax.get_xlim()[1]], [nrows+0.15, nrows+0.15], lw=1.5, color='grey', marker='', zorder=4)
    # Base Line
    ax.plot([ax.get_xlim()[0], ax.get_xlim()[1]], [-0.5, -0.5], lw=1.5, color='grey', marker='', zorder=4)
    # Line Between Table Items
    for x in range(1, nrows):
        ax.plot([ax.get_xlim()[0], ax.get_xlim()[1]], [x-.25, x-.25], lw=1.25, color='gray', ls=':', zorder=3 , marker='')


    import matplotlib.image as mpimg
    for index, team in enumerate(grouped_df['Team']):
        img = mpimg.imread("/content/drive/MyDrive/NWFL/team-assets_2023_24/{}.png".format(team.replace(" ", "-").lower()))
        # Specify the extent (xmin, xmax, ymin, ymax) for the inset image in data coordinates
        image_size = [1, 2, 1, 2]
        # Add an inset axes to the main plot
        ax_inset = fig.add_axes([0.13, 0.81 - (index*0.044), 0.03, 0.03])
        # Add the image to the inset axes
        ax_inset.imshow(img, extent=image_size, aspect='auto')  # 'auto' maintains the aspect ratio of the image
        ax_inset.set_axis_off()

    from matplotlib.patheffects import withStroke
    # Top Padding
    pad_top = fig.text(0.35,1.05, s=hspace)
    # Name Text
    name_text = fig.text(0.15,0.1, s=author, fontweight="regular", color="grey")
    # Minutes Breakdown Line
    min_line = fig.text(0.45,0.92, s="_"*40, color='black',
                      font="Oswald", fontsize=16, fontweight="light")

    if dist == "goals_for":
      # Minutes Breakdown Label
        min_text = fig.text(0.55,0.93, s="Minute Breakdown of Goals Scored", color='black',
                          font="Oswald", fontsize=14, fontweight="light")
        # Plot Title
        figtext = fig.text(0.25,1.00, s="WHEN ARE THE TEAMS SCORING ?", color='white',
                          font="Anton", fontsize=28, fontweight="bold")
    elif dist == "goals_allowed":
      # Minutes Breakdown Label
        min_text = fig.text(0.53,0.93, s="Minute Breakdown of Goals Conceded", color='black',
                          font="Oswald", fontsize=14, fontweight="light")
        # Plot Title
        figtext = fig.text(0.25,1.00, s="WHEN ARE THE TEAMS CONCEDING ?", color='white',
                          font="Anton", fontsize=28, fontweight="bold")

    # Set patheffects
    grey_patheffects = [withStroke(foreground="grey", linewidth=3.5)]
    figtext.set_path_effects(grey_patheffects)
    black_patheffects = [withStroke(foreground="black", linewidth=0.08)]
    min_text.set_path_effects(black_patheffects)


    # Add NWFL Logo
    logo = mpimg.imread("/content/drive/MyDrive/NWFL/team-assets_2023_24/nwfl-logo.png")
    # Specify the extent (xmin, xmax, ymin, ymax) for the inset image in data coordinates
    image_size = [1, 2, 1, 2]
    # Add an inset axes to the main plot
    ax_inset = fig.add_axes([0.12, 0.82, 0.15, 0.15])
    # Add the image to the inset axes
    ax_inset.imshow(logo, extent=image_size, aspect='auto')  # 'auto' maintains the aspect ratio of the image
    ax_inset.set_axis_off()

    # Save Fig
    if dist == "goals_for":
      plt.savefig("/content/drive/MyDrive/NWFL/plots/when-are-the-teams-scoring_23_24_mid_nwfl.png", dpi=200)
    elif dist == "goals_allowed":
      plt.savefig("/content/drive/MyDrive/NWFL/plots/when-are-the-teams-conceding_23_24_mid_nwfl.png", dpi=200)
    plt.show();

time_dist_of_goals(dist="goals_for")

time_dist_of_goals(dist="goals_allowed")

"""### **GOALS AVERAGES**

#### **2023/24 GOALS AVERAGES**

#####**WRANGLE ACT**
"""

df24.Group.value_counts()
GroupA_df = df24.loc[df24["Group"]=="A"].reset_index()
GroupB_df = df24.loc[df24["Group"]=="B"].reset_index()

GroupA_df.drop("index", axis=1, inplace=True)
GroupA_df

GroupB_df.drop("index", axis=1, inplace=True)
GroupB_df

gls_df.head(3)

total_goals = gls_df.FT_GlsFor.sum()
print("Total Number of Goals Recorded in NWFL Midway 2023/24: ", total_goals)

# 2023/24 League Average (Goals)
LAvg_Gls = (((hgoals.FTGF.sum()) + (agoals.FTGF.sum()))/len(df24)).round(2)
print("The League Average for Goals Scored:", LAvg_Gls)

# Group A Average (Goals)
GrpA_AvgGls = ((GroupA_df.FTHG.sum() + GroupA_df.FTAG.sum()) / len(GroupA_df)).round(2)
print("The Group A Average for Goals Scored:", GrpA_AvgGls)
# Group B Average (Goals)
GrpB_AvgGls = ((GroupB_df.FTHG.sum() + GroupB_df.FTAG.sum()) / len(GroupB_df)).round(2)
print("The Group B Average for Goals Scored:", GrpB_AvgGls)

print('Total Goals By Home Teams: ', hgoals.FTGF.sum())
print('Total Goals By Away Teams: ', agoals.FTGF.sum())
print("Total Number of Goals Recorded in NWFL Midway 2023/24: ", total_goals)
print('Total Games Played: ',len(df24))
print("The League Average for Goals:", LAvg_Gls)

print('Total Goals In Group A: ', GroupA_df.FTHG.sum() + GroupA_df.FTAG.sum())
print('Total Goals In Group B: ', GroupB_df.FTHG.sum() + GroupB_df.FTAG.sum())
print('Total Games Played Per Group: ',len(GroupA_df))

"""#####**PLOT VIZ**"""

# Data

# Create a figure and axes with dark background
fig, ax = plt.subplots(figsize=(12, 8))
fig.patch.set_facecolor('white')  # Dark background color

# Set Group Scatter Colors
GrpA_color = '#C8553D'
GrpB_color = '#C6A031'

# Scatter plot
for i, team in gls_df.iterrows():
    x_value = team['FT_GF_Avg']
    y_value = team['FT_GA_Avg']
    # Decide color
    if team.Teams in GrpA:
       grp_color = GrpA_color
    else:
       grp_color = GrpB_color

    # Plot Scatter
    scatter = ax.scatter(x_value, y_value, color=grp_color, edgecolor='grey',
                         alpha=0.7, zorder=4)

    # Add text above each scatter point with a black outline
    if (team.Teams == "Heartland Queens")  | (team.Teams == "Nasarawa Amazons"):
      offset = -0.1
    else:
      offset = 0.1
    team_txt = ax.text(x_value, y_value + offset, team.Teams,
            ha='center', va='center', color='black', zorder=5, fontweight='light',
            fontsize=10)#, path_effects=[withStroke(linewidth=.001, foreground='black')])
    #team_txt.set_path_effects([path_effects.Stroke(linewidth=.005, foreground='black'),
    #                          path_effects.Normal()])

# Customize the scatter plot
ax.set_xlim(0.0, 3.0)
ax.set_ylim(0.0, 3.0)
ax.set_facecolor('white')  # set background color
# Change the color of ticks to red
ax.tick_params(axis='both', colors='black')
hide_spines(axes=ax, which_spine='all')

# Showing League Average
plt.axvline(x=LAvg_Gls, linestyle='--', color='#588B8B', alpha=.8)
plt.axhline(y=LAvg_Gls, linestyle='--', color='#588B8B', alpha=.8)
# Add arrow and text at the point of intersection
arrow_properties = dict(facecolor='white', edgecolor='grey', arrowstyle='->')
ax.annotate('({}) LAvg'.format(LAvg_Gls),
            xy=(LAvg_Gls, LAvg_Gls), xycoords='data',
            xytext=(2.5, 2.5), textcoords='data',
            arrowprops=arrow_properties,
            fontsize=10, color='#588B8B',
            path_effects=[withStroke(linewidth=.005, foreground='#588B8B')])
# Showing Group A Average
plt.axvline(x=GrpA_AvgGls, linestyle='--', color='grey', alpha=.6)
plt.axhline(y=GrpA_AvgGls, linestyle='--', color='grey', alpha=.6)
ax.annotate('({}) Group A'.format(GrpA_AvgGls),
            xy=(GrpA_AvgGls, GrpA_AvgGls), xycoords='data',
            xytext=(1.68, 1.38), textcoords='data',
            arrowprops=arrow_properties,
            fontsize=10, color=GrpA_color,
            path_effects=[withStroke(linewidth=.005, foreground=GrpA_color)])
# Showing Group B Average
plt.axvline(x=GrpB_AvgGls, linestyle='--', color='grey', alpha=.6)
plt.axhline(y=GrpB_AvgGls, linestyle='--', color='grey', alpha=.6)
ax.annotate('({}) Group B'.format(GrpB_AvgGls),
            xy=(GrpB_AvgGls, GrpB_AvgGls), xycoords='data',
            xytext=(2.15, 1.98), textcoords='data',
            arrowprops=arrow_properties,fontweight='normal',
            fontsize=10, color=GrpB_color,
            path_effects=[withStroke(linewidth=.005, foreground=GrpB_color)])

# # Set axis labels
# ax.set_xlabel('Goals Allowed Average', color='grey')
# ax.set_ylabel('Goals For Average', color='grey')

# # Set title
# ax.set_title('Mid Season Goals Averages (2023/24)'.upper(), color='grey')
# # ax.text(x=1.5,y=-.5,s='LAvg = League Average', color='grey', ha='center',va='center')
# # ax.text(x=1.5,y=-.75,s='{}'.format(author), color=plot_color, ha='center',va='center')
# # Save Fig
# plt.savefig("/content/drive/MyDrive/NWFL/plots/goals_avg_23_24_mid_nwfl.png", dpi=200)
# # Show the plot
plt.show();

"""#### **2022/23 GOALS AVERAGES**

#####**WRANGLE ACT**
"""

teams_2223 = sorted(list(df23.loc[df23['Group'] == 'A']['Home Team'].unique())) + sorted(list(df23.loc[df23['Group'] == 'B']['Home Team'].unique()))
teams_2223

total_goals23 = comb23.FT_GlsFor.sum()
print("Total Number of Goals Recorded in NWFL Midway 2022/23: ", total_goals23)

df23.Group.value_counts()

# 2022/23 League Average (Goals)
LAvg_Gls23 = ((df23.FTHG.sum())/len(df23)).round(2)
print("The League Average for Goals Scored:", LAvg_Gls23)

# Group dfs
GroupA_df23 = df23.loc[df23["Group"]=="A"].reset_index()
GroupB_df23 = df23.loc[df23["Group"]=="B"].reset_index()

# Group A Average (Goals)
GrpA_AvgGls23 = ((GroupA_df23.FTHG.sum()+GroupA_df23.FTAG.sum())/len(GroupA_df)).round(2)
print("The Group A Average for Goals Scored:", GrpA_AvgGls23)
# Group B Average (Goals)
GrpB_AvgGls23 = ((GroupB_df23.FTHG.sum()+GroupB_df23.FTAG.sum())/len(GroupB_df)).round(2)
print("The Group B Average for Goals Scored:", GrpB_AvgGls23)

print('Total Goals In Group A: ', GroupA_df23.FTHG.sum()+GroupA_df23.FTAG.sum())
print('Total Goals In Group B: ', GroupB_df23.FTHG.sum()+GroupB_df23.FTAG.sum())
print('Total Games Played Per Group: ',len(GroupA_df23))

goals_agg(df=df23.fillna(0))

"""#####**PLOT VIZ**"""

# Data
season ="2022/23"
lavg = LAvg_Gls23
grpa_avg = GrpA_AvgGls23
grpb_avg = GrpB_AvgGls23

GrpA_color = '#C8553D'
GrpB_color = '#C6A031'

# Create a figure and axes with dark background
fig, ax = plt.subplots(figsize=(12, 6))
fig.patch.set_facecolor('white') # Dark background color

# Scatter plot
for i, team in comb23.iterrows():
    x_value = team['FT_GF_Avg']
    y_value = team['FT_GA_Avg']
    # Decide color
    if team.Teams in GrpA23:
       grp_color = GrpA_color
    else:
       grp_color = GrpB_color

    # Plot Scatter
    scatter = ax.scatter(x_value, y_value, color=grp_color, edgecolor='grey',
                         alpha=0.7, zorder=5)

    # Add text above each scatter point with a white outline
    # for i, item in enumerate(items):
    ax.text(x_value, y_value + 0.1, team.Teams,
            ha='center', va='center', color='black', zorder=4, fontweight='normal',
            fontsize=10, path_effects=[withStroke(linewidth=0.25, foreground='black')])

# Customize the scatter plot
ax.set_xlim(0.0, 3.0)
ax.set_ylim(0.0, 3.0)
ax.set_facecolor('white')  # Dark background color
# Change the color of ticks to red
ax.tick_params(axis='both', colors='#588B8B')
hide_spines(axes=ax, which_spine='all')

# Showing League Average
plt.axvline(x=lavg, linestyle='--', color='#588B8B', alpha=.8)
plt.axhline(y=lavg, linestyle='--', color='#588B8B', alpha=.8)
# Add arrow and text at the point of intersection
arrow_properties = dict(facecolor='white', edgecolor='grey', arrowstyle='->')
ax.annotate('({}) LAvg'.format(lavg),
            xy=(lavg, lavg), xycoords='data',
            xytext=(2.5, 2.5), textcoords='data',
            arrowprops=arrow_properties,
            fontsize=10, color='#588B8B',
            path_effects=[withStroke(linewidth=0.25, foreground='black')])
# Showing Group A Average
plt.axvline(x=grpa_avg, linestyle='--', color='grey', alpha=.6)
plt.axhline(y=grpa_avg, linestyle='--', color='grey', alpha=.6)
ax.annotate('({}) Group A'.format(grpa_avg),
            xy=(grpa_avg, grpa_avg), xycoords='data',
            xytext=(1.68, 1.38), textcoords='data',
            arrowprops=arrow_properties,
            fontsize=10, color=GrpA_color,
            path_effects=[withStroke(linewidth=0.25, foreground='black')])
# Showing Group B Average
plt.axvline(x=grpb_avg, linestyle='--', color='grey', alpha=.6)
plt.axhline(y=grpb_avg, linestyle='--', color='grey', alpha=.6)
ax.annotate('({}) Group B'.format(grpb_avg),
            xy=(grpb_avg, grpb_avg), xycoords='data',
            xytext=(2.15, 1.98), textcoords='data',
            arrowprops=arrow_properties,
            fontsize=10, color=GrpB_color,
            path_effects=[withStroke(linewidth=0.25, foreground='black')])

# Set axis labels
# ax.set_xlabel('Goals Allowed Average', color='grey')
# ax.set_ylabel('Goals For Average', color='grey')

#ax.set_ylabel('Goals Allowed Average', color='grey')
#ax.set_xlabel('Goals For Average', color='grey')

# Set title
#ax.set_title(f'Mid Season Goals Averages {(season)}'.upper(), color='grey')
# Save Fig
#plt.savefig("/content/drive/MyDrive/NWFL/plots/goals_avg_22_23_mid_nwfl.png", dpi=200)

# Show the plot
plt.show();

"""### **OWN GOALS**"""

own_goals = goals24_mod.loc[goals24_mod["own_goal"]!=0]
own_goals

"""### **PENALTY GOALS**"""

pen_goals = goals24_mod.loc[goals24_mod["penalty"]!=0]
pen_goals

"""### **NUMBER OF GOALSCORERS PER TEAM**"""

print("Number of Unique Goalscorers 2023/24 Mid-Season: ", goals24_mod['Player Name'].nunique())

gscorers_per_team = goals24_mod.loc[goals24_mod["own_goal"]!=1]
gscorers_per_team

team_gscorers = gscorers_per_team.groupby("Team Name")['Player Name'].nunique().reset_index();
sorted_gscorers = team_gscorers.sort_values(by="Player Name", ascending=False)
sorted_gscorers.reset_index(drop=True)

"""### **GOALS IN CONSECUTIVE MATCHES**

####**PLAYER BASED**
"""

# All Match Days Per Team
all_matchdays = {}
# Using df24 as the DataFrame
df24['Date'] = pd.to_datetime(df24['Date'], format='%d/%m/%Y')
sorted_df24 = df24.sort_values(by="Date")
for team in list_of_teams:
  team_df = sorted_df24.loc[(sorted_df24['Home Team'] == team) | (sorted_df24['Away Team'] == team)].reset_index(drop=True)
  # convert date back to string object
  team_df['Date'] = team_df.Date.astype(str)
  # Get all date strings
  match_days = team_df.Date.unique()
  # update dictionary
  all_matchdays[team] = list(match_days)

# view dictionary
all_matchdays

show_all_cells(False)
goals24_mod['Player Name'].value_counts()

multiple_goals = goals24_mod['Player Name'].value_counts().reset_index()
multiple_goals = multiple_goals[multiple_goals['Player Name']>1]
multiple_goals.head()

print("Only {} Players Have Scored More Than One Goal at 2023/24 Mid-Season and they have {} goals between them!".format(len(multiple_goals), multiple_goals['Player Name'].sum()))

multiple_gscorers_list = multiple_goals['index'].to_list()

show_all_cells(False)
consec_gms = goals24_mod[goals24_mod['Player Name'].isin(multiple_gscorers_list)]
consec_gms = consec_gms.reset_index(drop=True)
# Dropping all instances of own goals (incase they sneaked past the first checkpoint)
consec_gms = consec_gms.loc[consec_gms['own_goal'] !=1]

consec_gms.head()

consec_gms.info()

# convert to datetime
consec_gms['Date'] = pd.to_datetime(consec_gms['Date'], format='%d/%m/%Y')
# sort by Date
sorted_consec = consec_gms.sort_values(by="Date")
sorted_consec = sorted_consec.reset_index(drop=True)
sorted_consec

# All Matchdays Where Each Goalscorer Scored at least one Goal
grouped_consec = sorted_consec.groupby(['Player Name', 'Team Name'])['Date'].unique()
grouped_consec = grouped_consec.reset_index()
grouped_consec

# Dropping rows where multiple goals were scored but it was just in one match
indices_to_delete = []
for i in range(len(grouped_consec)):
  if len(grouped_consec['Date'][i]) <= 1:
    indices_to_delete.append(i)

# Delete rows by index
grouped_consec.drop(indices_to_delete, inplace=True)
grouped_consec = grouped_consec.reset_index(drop=True)
grouped_consec

# store final streak list per player
player_goals = {}

for i, datelist in enumerate(grouped_consec['Date']):
    # fetching team match days from all_matchdays
    matchday = all_matchdays.get(grouped_consec['Team Name'][i])
    # getting a sorted list of dates when the player scored
    date = sorted(datelist)

    # comparing dates
    matches = []  # reset matches for each player
    j = k = 0  # reset indices for each player
    while j < len(date) and k < len(matchday):
        formatted_date = pd.to_datetime(date[j]).strftime('%Y%m%d')
        formatted_matchday = pd.to_datetime(matchday[k]).strftime('%Y%m%d')
        #
        if formatted_date == formatted_matchday:
            matches.append(1)
            j += 1
            k += 1
        else:
            matches.append(0)
            k += 1
    # check if there are remaining match days
    while k < len(matchday):
        matches.append(0)
        k += 1
    # Join the binary list into a string
    match_string = ''.join(map(str, matches))
    # update dictionary
    player_goals[grouped_consec['Player Name'][i]] = match_string

# view dictionary
player_goals

# Create a list to store streak information
streak_data = []

# Iterate over player_goals dictionary
for player, match_string in player_goals.items():
    # Split match_string by '0' character and get the lengths of consecutive '1' streaks
    streaks = [len(streak) for streak in match_string.split('0')]

    # Get the maximum streak length
    max_streak = max(streaks)

    # Append player and max_streak to streak_data
    streak_data.append({'Name': player, 'Streak': max_streak})

# Create DataFrame from streak_data
streak_df = pd.DataFrame(streak_data)

# Filter rows where the streak is greater than 1
streak_df = streak_df[streak_df['Streak'] > 1]

# Reset index
streak_df = streak_df.reset_index(drop=True)

# Sort by Streak
streak_df = streak_df.sort_values('Streak', ascending=False)

# Reset index again
streak_df = streak_df.reset_index(drop=True)
streak_df

"""### **ON HOW MANY MATCHDAYS HAVE THE TEAMS SCORED THIS SEASON ?**"""

# Match Days When The Teams Scored
md_scored = {}
# Assuming df is your DataFrame
goals24['Date'] = pd.to_datetime(goals24['Date'], format='%d/%m/%Y')
sorted_goals24 = goals24.sort_values(by="Date")
for team in sorted(goals24['Team Name'].unique()):
  team_df = sorted_goals24.loc[sorted_goals24['Team Name'] == team].reset_index(drop=True)
  # convert date back to string object
  team_df['Date'] = team_df.Date.astype(str)
  # et the match days list in ascending order
  match_days = team_df.Date.unique()
  # update dictionary
  md_scored[team] = list(match_days)

# view dictionary
md_scored

for key in md_scored.keys():
  print("{} has scored on ({}) out of 7 matchdays this season".format(key, len(md_scored.get(key))))

# Convert dictionary to DataFrame
df = pd.DataFrame(list(md_scored.items()), columns=['Teams', 'Matchdays'])
# Update "Matchdays" column with the length of each list
df['Matchdays'] = df['Matchdays'].apply(len)
df.sort_values(by="Matchdays", ascending=False).reset_index(drop=True)

"""### **COMMON SCORELINES**

Common Scorelines - May Be Expressed In Pct or Prob

#### **COMBINED**

#####**PROBABILITY DISTRIBUTION**
"""

# Full Time
common_scoreline(df=df24, period='FTR', viz_type='probabilities')

# Half Time
common_scoreline(df=df24, period='HTR', viz_type='probabilities')

# Second Half
common_scoreline(df=df24, period='SHR', viz_type='probabilities')

"""#####**PERCENTAGE DISTRIBUTION**"""

# Full Time
common_scoreline(df=df24, period='FTR', viz_type="Percentages")

# Half Time
common_scoreline(df=df24, period='HTR', viz_type='percentages')

# Second Half
common_scoreline(df=df24, period='SHR', viz_type='percentages')

"""#### **PER GROUP**"""

# Group A
grpA_common_score = df24.loc[df24['Group']=='A']
len(grpA_common_score)

# Group B
grpB_common_score = df24.loc[df24['Group']=='B']
len(grpB_common_score)

"""#####**GROUP A**"""

common_scoreline(df=grpA_common_score, period='FTR', viz_type='probabilities')

common_scoreline(df=grpA_common_score, period='HTR', viz_type='probabilities')

common_scoreline(df=grpA_common_score, period='SHR', viz_type='probabilities')

"""#####**GROUP B**"""

common_scoreline(df=grpB_common_score, period='FTR', viz_type='probabilities')

# common_scoreline(df=grpB_common_score, period='FTR', viz_type='percentages')

common_scoreline(df=grpB_common_score, period='HTR', viz_type='probabilities')

common_scoreline(df=grpB_common_score, period='SHR', viz_type='probabilities')

"""## **HOME VERSUS AWAY (RESULT DISTRIBUTION & GOALS) IN COMPARSION TO 2022/23**"""

print("Goals Scored in 2023/24 NWFL Mid-Season by Home Teams: ", df24.FTHG.sum())
print("Goals Scored in 2023/24 NWFL Mid-Season by Away Teams: ", df24.FTAG.sum())

print("Goals Scored in 2022/23 NWFL Mid-Season by Home Teams: ", df23.FTHG.sum())
print("Goals Scored in 2022/23 NWFL Mid-Season by Away Teams: ", df23.FTAG.sum())

# Calculating The Total Goals Scored In The 2022/23 Season
total_goals23 = df23.FTHG.sum() + df23.FTAG.sum()
print("Total Goals Scored in 2022/23 NWFL Mid-Season: ", total_goals23)
print("Total Games Played in 2022/23 NWFL Mid-Season: ", len(df23))
print("League Goals Avg in 2022/23 NWFL Mid-Season: ", round(total_goals23/len(df23), 2))

#
ax = sns.countplot(x = df24['FTR'] , data = df24, color=plot_color, order=['H','A','D'])
for container in ax.containers:
    ax.bar_label(container)

ax = sns.countplot(x = df23['FTR'] , data = df23, color=plot_color, order=['H','A','D'])
for container in ax.containers:
    ax.bar_label(container)

"""## **PER GAME WEEK**

###**RESULTS DISTRIBUTION**
"""

# Group by 'GameWeek' and count the occurrences of each 'FTR' value
result24 = df24.groupby(['Game Week', 'FTR']).size().unstack(fill_value=0)

# Rename columns for better clarity
result24.columns = ['Away Wins', 'Draws', 'Home Wins']

# Reset Index
result24 = result24.reset_index()

# Display the result
result24

# Group by 'GameWeek' and count the occurrences of each 'FTR' value
result23 = df23.groupby(['Game Week', 'FTR']).size().unstack(fill_value=0)

# Rename columns for better clarity
result23.columns = ['Away Wins', 'Draws', 'Home Wins']

# Reset Index
result23 = result23.reset_index()

# Display the result
result23

"""###**GOALS ON GAME WEEK**"""

# 2023/24
h = df24.groupby('Game Week')['FTHG', 'FTAG'].sum().reset_index(drop=True)
h['Goals_gw'] = h.FTHG + h.FTAG

h
h.sort_values(by='Goals_gw', ascending=False)

# 2022/23
g = df23.groupby('Game Week')['FTHG', 'FTAG'].sum().reset_index(drop=True)
g['Goals_gw'] = g.FTHG + g.FTAG

g
g.sort_values(by='Goals_gw', ascending=False)

# Goals Per GW  (2023/24)
#print("Game Week {} produced the most goals with {} Goals".format())
# Goals Per GW (2022/23)

import matplotlib.pyplot as plt

# Sample data
game_weeks = [1, 2, 3, 4, 5, 6, 7]
home_wins = [6, 4, 4, 2, 3, 2, 3]
away_wins = [0, 1, 1, 1, 1, 2, 1]
draws = [0, 1, 1, 3, 2, 2, 2]

# Bar plot
bar_width = 0.25
index = range(len(game_weeks))

plt.bar(index, home_wins, width=bar_width, label='Home Wins')
plt.bar([i + bar_width for i in index], away_wins, width=bar_width, label='Away Wins')
plt.bar([i + 2 * bar_width for i in index], draws, width=bar_width, label='Draws')

plt.xlabel('Game Week')
plt.ylabel('')
plt.title('Distribution of Home Wins, Away Wins, and Draws Per Game Week')
plt.xticks([i + bar_width for i in index], game_weeks)
plt.legend()

plt.show();

"""##**GD ANALYSES**

#####**GD DATAFRAME**
"""

gd_df = df24[['Home Team', 'Away Team', 'FTHG', 'FTAG',
              'FTR', 'HomeTeam Goals', 'AwayTeam Goals']]

# Process Missing Values in HomeTeam Goals and AwayTeam Goals columns
# We're using 404 because it is a common error code and football matches don't reach 404 minutes
# It is formatted as a bracketed string for consistency with other rows
gd_df['HomeTeam Goals'] = gd_df['HomeTeam Goals'].fillna('(404)')
gd_df['AwayTeam Goals'] = gd_df['AwayTeam Goals'].fillna('(404)')

# Process HomeTeam Goals and AwayTeam Goals columns
gd_df['HomeTeam Goals'] = gd_df['HomeTeam Goals'].apply(extract_numbers)
gd_df['AwayTeam Goals'] = gd_df['AwayTeam Goals'].apply(extract_numbers)

gd_df.head(3)

"""####**GD CHART**

#####**2023/24**
"""

grp_a, _a = calculate_standings(df=df24, game_week=7, group='a')
grp_b, _b = calculate_standings(df=df24, game_week=7, group='b')
grp_a
grp_b

"""#####**2022/23**"""

grp_a23, _a23 = calculate_standings(df=df23, game_week=7, group='a')
grp_b23, _b23 = calculate_standings(df=df23, game_week=7, group='b')
grp_a23
grp_b23

"""###**MATCH OPENERS**

####**WRANGLE ACT**
"""

gls_gms = df24.loc[(df24['FTHG'] != 0) | (df24['FTAG'] != 0)]
len(gls_gms)

no_gls_in_gms = df24.loc[(df24['FTHG'] == 0) & (df24['FTAG'] == 0)]
len(no_gls_in_gms)

# select dataframe
df = gd_df.copy()

# Pts_Pos Dict of Dataframes
Pts_Pos = {}
# Create opener dictionaries
opener_home = {}
opener_away = {}

for team in list_of_teams:
    # Get the team dataframe
    x = df.loc[(df['Home Team'] == team) | (df['Away Team'] == team)]
    # Replacing with the time of first goal
    x['HomeTeam Goals'] = x['HomeTeam Goals'].apply(lambda x: min(map(int, x)) if isinstance(x, list) else x)
    x['AwayTeam Goals'] = x['AwayTeam Goals'].apply(lambda x: min(map(int, x)) if isinstance(x, list) else x)

    # subset dfs
    x_home = x.loc[x['Home Team']==team]
    x_away = x.loc[x['Away Team']==team]

    # 1 for when team scored opener
    # -1 for when they conceded the opener
    # 0 for goalless affairs
    x_home['opener'] = np.where(x_home['HomeTeam Goals'] > x_home['AwayTeam Goals'], -1,
                                np.where(x_home['HomeTeam Goals'] < x_home['AwayTeam Goals'], 1, 0))
    # same as x_home
    x_away['opener'] = np.where(x_away['HomeTeam Goals'] < x_away['AwayTeam Goals'], -1,
                                np.where(x_away['HomeTeam Goals'] > x_away['AwayTeam Goals'], 1, 0))
    # reset dfs
    x_home = x_home.reset_index(drop=True)
    x_away = x_away.reset_index(drop=True)

    # Updating Pts_Pos Dataframe
    Pts_Pos[team] = pd.concat([x_home,x_away], ignore_index='True')

    # Populate opener_home dictionary
    # calculating dictionary values
    opener_scored = x_home['opener'].value_counts().get(1,0)
    opener_conc = x_home['opener'].value_counts().get(-1,0)
    # populate dictionary
    opener_home[team] = {'scored_home': int(opener_scored), 'conc_home': int(opener_conc)}

    # Populate opener_away dictionary
    # calculating dictionary values
    opener_scored = x_away['opener'].value_counts().get(1,0)
    opener_conc = x_away['opener'].value_counts().get(-1,0)
    # populate dictionary
    opener_away[team] = {'scored_away': int(opener_scored), 'conc_away': int(opener_conc)}

# Create DataFrames from both dictionaries
_away = pd.DataFrame(opener_away).transpose().reset_index()
# Rename columns
_away.columns = ['Team', 'scored_away', 'conceded_away']
# sort
sorted_away = _away.sort_values(by="Team")

# Create DataFrames from the Home dictionary
_home = pd.DataFrame(opener_home).transpose().reset_index()
# Rename columns
_home.columns = ['Team', 'scored_home', 'conceded_home']
# sort
sorted_home = _home.sort_values(by="Team")

# Concatenate DataFrames
opener_df = pd.merge(sorted_home, sorted_away, on="Team")

# Viewing dataframe
opener_df["Total_Scored"] = opener_df.scored_home + opener_df.scored_away
opener_df["Total_Conceded"] = opener_df.conceded_home + opener_df.conceded_away

# View Dataframe
opener_df

# Confirming the counts of the openers_df
# Using two because for every opner scored, it was also conceded by the opposing team so each opener has a double count
2*len(gls_gms) == opener_df.scored_home.sum() +	opener_df.conceded_home.sum() +	opener_df.scored_away.sum() + opener_df.conceded_away.sum()

"""####**MOST OPENERS SCORED**"""

# Most Openers Combined
opener_df[['Team','Total_Scored']].sort_values(by="Total_Scored", ascending=False).reset_index(drop=True)

# Most Openers At Home
opener_df[['Team','scored_home']].sort_values(by="scored_home", ascending=False).reset_index(drop=True)

# Most Openers Away
opener_df[['Team','scored_away']].sort_values(by="scored_away", ascending=False).reset_index(drop=True)

"""####**MOST OPENERS CONCEDED**"""

# Most Openers Combined
opener_df[['Team','Total_Conceded']].sort_values(by="Total_Conceded", ascending=False).reset_index(drop=True)

# Most Openers At Home
opener_df[['Team','conceded_home']].sort_values(by="conceded_home", ascending=False).reset_index(drop=True)

# Most Openers Away
opener_df[['Team','conceded_away']].sort_values(by="conceded_away", ascending=False).reset_index(drop=True)

"""###**PTS FROM POS**

####**POINTS WON FROM LOSING POSITIONS**

#####**WRANGLE ACT**
"""

# The Assumption is that winning at Home and Away have the same weights
# and it is not difficult to win at a stadium than another

# Init Value
draws = 1
wins = 3

# Dict
pts_frm_loss = {}

# Since the team must start by conceding, we need rows where opener is -1
for team in list_of_teams:
    # Resets points tally for each Team
    pts_tally = 0
    # Get Team Dataframe From Pts_Pos Dict
    # The Pts_Pos wass gotten from categorizing the games by match openers
    team_df = Pts_Pos.get(team, None)

    # Get df of where the team conceded first
    frm_loss_df = team_df.loc[team_df.opener == -1]
    # View each df in case of debugging
    # frm_loss_df

    for index, sub_df in frm_loss_df.iterrows():
        if sub_df['FTR'] == 'D':
          pts_tally +=draws
        elif (sub_df['Home Team'] == team):
          if sub_df['FTR'] == 'H':
              pts_tally +=wins
        elif sub_df['Away Team'] ==team:
          if sub_df['FTR'] == 'A':
              pts_tally +=wins

        pts_frm_loss[team] = pts_tally

# Uncomment for Debugging
# View Dict
# pts_frm_loss

# # Create DataFrames
pts_won_frm_loss_pos_df = pd.DataFrame(list(pts_frm_loss.items()), columns=['Team', 'Points Won'])
# pts_won_frm_loss_pos_df

"""#####**MOST POINTS WON FROM LOSING POSITIONS**"""

pts_won_frm_loss_pos_df.sort_values(by='Points Won', ascending=False).reset_index(drop=True)

"""####**POINTS DROPPED FROM WINNING POSITIONS**

#####**WRANGLE ACT**
"""

# The Assumption is that winning at Home and Away have the same weights
# and it is not difficult to win at a stadium than another

# Init Value
draws = -2
loss = -3

# Dict
pts_frm_win = {}

# Since the team must start by conceding, we need rows where opener is -1
for team in list_of_teams:
    # Resets points tally for each Team
    pts_tally = 0
    # Get Team Dataframe From Pts_Pos Dict
    # The Pts_Pos wass gotten from categorizing the games by match openers
    team_df = Pts_Pos.get(team, None)

    # Get df of where the team conceded first
    frm_win_df = team_df.loc[team_df.opener == 1]
    # # Uncomment for debugging to seeeach team df
    # frm_win_df

    for index, sub_df in frm_win_df.iterrows():
        if sub_df['FTR'] == 'D':
          pts_tally +=draws
        elif (sub_df['Home Team'] == team):
          if sub_df['FTR'] == 'A':
              pts_tally +=loss
        elif sub_df['Away Team'] ==team:
          if sub_df['FTR'] == 'H':
              pts_tally +=loss

        pts_frm_win[team] = abs(pts_tally)

# # Uncomment for Debugging
# # View Dict
# pts_frm_win

# Create DataFrames
pts_drp_frm_win_pos_df = pd.DataFrame(list(pts_frm_win.items()), columns=['Team', 'Points Dropped'])
# pts_frm_win_pos_df

"""#####**MOST PTS DROPPED FROM WINNING POSITIONS**"""

pts_drp_frm_win_pos_df.sort_values(by='Points Dropped', ascending=False).reset_index(drop=True)

"""###**%MINUTES TRAILING, LEADING OR DRAWING PER TEAM**

#####**OLD CODE**
"""

# Assuming df is your original DataFrame with match data
# Let's select a team randomly (for example, "Ekiti Queens")
# selected_team = "Ekiti Queens" #Maija Ratels Adamawa Queens

def get_games(select_team):
    # Team
    selected_team = select_team
    # Filter rows where the selected team is either Home Team or Away Team
    home_matches = df[df['Home Team'] == selected_team]
    away_matches = df[df['Away Team'] == selected_team]


    # Initialize an empty list to store dictionaries for each match
    matches_data = []

    # Process home matches
    for index, row in home_matches.iterrows():
        match_data = {
            'Team': selected_team,
            'Opponent': row['Away Team'],
            'FTTG': row['FTHG'],
            'FTOG': row['FTAG'],
            'TeamGoals': row['HomeTeam Goals'],
            'OppGoals': row['AwayTeam Goals']
        }

        # Determine FTR based on match result
        if row['FTR'] == 'H':
            match_data['FTR'] = 'W'
        elif row['FTR'] == 'A':
            match_data['FTR'] = 'L'
        else:
            match_data['FTR'] = 'D'

        matches_data.append(match_data)

    # Process away matches
    for index, row in away_matches.iterrows():
        match_data = {
            'Team': selected_team,
            'Opponent': row['Home Team'],
            'FTTG': row['FTAG'],
            'FTOG': row['FTHG'],
            'TeamGoals': row['AwayTeam Goals'],
            'OppGoals': row['HomeTeam Goals']
        }

        # Determine FTR based on match result
        if row['FTR'] == 'A':
            match_data['FTR'] = 'W'
        elif row['FTR'] == 'H':
            match_data['FTR'] = 'L'
        else:
            match_data['FTR'] = 'D'

        matches_data.append(match_data)

    # Create the final DataFrame
    empty_df = pd.DataFrame(matches_data)

    # Add Extra columns for match minutes
    empty_df['0_3'] = 0
    empty_df['0_2'] = 0
    empty_df['0_1'] = 0
    empty_df['0_0'] = 0
    empty_df['1_0'] = 0
    empty_df['2_0'] = 0
    empty_df['3_0'] = 0
    # Column to track match map
    empty_df['match_map'] = ""

    # Display the populated DataFrame
    return empty_df

def update_minutes(gd):
    """
    Accepts Goal Difference at any instance of time, and returns column name to be updated
    """
    if gd >= 3:
        # return the appropriate column label
        return "3_0"
    elif gd == 2:
        # return the appropriate column label
        return "2_0"
    elif gd == 1:
        # return the appropriate column label
        return "1_0"
    elif gd == 0:
        # return the appropriate column label
        return "0_0"
    elif gd == -1:
        # return the appropriate column label
        return "0_1"
    elif gd == -2:
        # return the appropriate column label
        return "0_2"
    elif gd <= -3:
        # return the appropriate column label
        return "0_3"

#get_games('Adamawa Queens')

# team = "Adamawa Queens"
# team_df = get_games(team)

# # Loop over the DataFrame Rows
# for i, sub_df in team_df.iterrows():
#     # To hold the game states
#     map_list = []

#     # Goalless Draws
#     if (sub_df.FTTG == 0) and (sub_df.FTOG == 0):
#         team_df['0_0'] += 90
#         # track current match score
#         curr_score = "{}_{}".format(0,0)
#         map_list.append(curr_score)

#     else:
#         # init variable to track when last goal was scored
#         last_goal_time = 0
#         # possible lengths of goals scored (dont forget the 404s!)
#         team_glen = len(sub_df.TeamGoals)
#         opp_glen = len(sub_df.OppGoals)

#         # track goals
#         team_score = opp_score = 0

#         # variable to loop over the goaltimes
#         j = k = 0

#         # comparing goal times
#         while j < len(sub_df.TeamGoals):

#             if (opp_glen > 1) and (k+1 == opp_glen):
#               t_j = 404
#             else:
#               t_j = sorted(sub_df.TeamGoals)[j]

#               while k < len(sub_df.OppGoals):
#                   opp_k = sorted(sub_df.OppGoals)[k]

#                   # track current match score
#                   curr_score ="{}_{}".format(team_score,opp_score)
#                   map_list.append(curr_score)

#                   # calculate goal difference
#                   gd = team_score - opp_score

#                   # get column to update
#                   score_col = update_minutes(gd)
#                   #print(score_col)

#                   # comparing goal times
#                   if t_j < opp_k:
#                       # update minutes
#                       team_df[score_col][i] += (t_j - last_goal_time)
#                       # update last goal time
#                       last_goal_time = t_j
#                       # update team goals (team_score)
#                       team_score +=1
#                       break

#                   elif t_j > opp_k:
#                       # update minutes
#                       team_df[score_col][i] += (opp_k - last_goal_time)
#                       # update last goal time
#                       last_goal_time = opp_k
#                       # update opponent goal
#                       opp_score +=1

#                       # update loop variable
#                       if (k+1 == len(sub_df.OppGoals)) and (t_j == 404):
#                         break
#                       #elif (k+1 == len(sub_df.OppGoals)) and (j+1 == len(sub_df.TeamGoals)):
#                         #break
#                       elif (k+1 == len(sub_df.OppGoals)) and (j < len(sub_df.TeamGoals)):
#                         k +=0
#                         #break ----j +=1
#                       else:
#                         k +=1

#               # update loop variable for team goaltimes
#               if (j+1 == len(sub_df.TeamGoals)) and (opp_k == 404):
#                 break
#               if (team_score == sub_df.FTTG) and (opp_score == sub_df.FTOG):
#                 break
#               elif (j+1 == len(sub_df.TeamGoals)) and (k < len(sub_df.OppGoals)):
#                 j +=0
#                 #----k +=1
#               else:
#                 j +=1


#     if (last_goal_time < 90):
#       # get final goal difference
#       final_gd = team_score - opp_score
#       col = update_minutes(final_gd)
#       team_df[col] += 90 - last_goal_time
#     else:
#       pass

#     # updating match map column
#     team_df.match_map[i] = map_list

# # Update last row of the df
# team_df

"""#####**ALFIAN HAKIM** x **ALLI**"""

# Getting the dataframe to be used
df_event = gd_df.copy()

# # Counting 404s
# fthg_404 = 0
# ftag_404 = 0

# Dataframe to hold the final dfs for concatenation
df_list = []

for i, mtch in df_event.iterrows():
    match_id = i
    home_team = mtch['Home Team']
    away_team = mtch['Away Team']
    list_goal = []
    for goal_minute in [int(item) for item in mtch['HomeTeam Goals']]:
        if goal_minute != 404:
            if goal_minute > 90:
               goal_minute = 90
        # elif goal_minute == 404:
        #     fthg_404 +=1
        # ----------- #
        dict_goal = {}
        # ----------- #
        dict_goal['match_id'] = match_id
        dict_goal['home_team'] = home_team
        dict_goal['away_team'] = away_team
        dict_goal['event'] = 'goal'
        dict_goal['minute_end'] = goal_minute
        # ------------ #
        dict_goal['home_new_score'] = 1
        dict_goal['away_new_score'] = 0
        # ------------ #
        list_goal.append(dict_goal)
        # print(dict_goal)
    # --------- AWAY TEAM GOALS ----------------- #
    for goal_minute in [int(item) for item in mtch['AwayTeam Goals']]:
        if goal_minute != 404:
            if goal_minute > 90:
              goal_minute = 90
        # elif goal_minute == 404:
        #     ftag_404 +=1
        # ------------- #
        dict_goal = {}
        # ------------- #
        dict_goal['match_id'] = match_id
        dict_goal['home_team'] = home_team
        dict_goal['away_team'] = away_team
        dict_goal['event'] = 'goal'
        dict_goal['minute_end'] = goal_minute
        # ------------ #
        dict_goal['home_new_score'] = 0
        dict_goal['away_new_score'] = 1
        # ------------ #
        list_goal.append(dict_goal)
        # print(dict_goal)
    # --------- FULL TIME AGG ----------------- #
    dict_ft = {}
    dict_ft['match_id'] = match_id
    dict_ft['home_team'] = home_team
    dict_ft['away_team'] = away_team
    dict_ft['event'] = 'z-ft'
    dict_ft['minute_end'] = 90
    dict_ft['home_new_score'] = 0
    dict_ft['away_new_score'] = 0
    # print(dict_ft)
    # ------Storing the Away Team------ #
    list_goal.append(dict_ft)
    # The Match Dataframe
    df_match = pd.DataFrame(list_goal)
    df_match.sort_values(['minute_end', 'event'], inplace=True)
    # setting init column entries in our columns as integers
    df_match['minute_start'] = 0
    df_match['minute_spend'] = 0
    df_match['home_score'] = 0
    df_match['away_score'] = 0
    df_match['home_gd'] = 0
    df_match['away_gd'] = 0
    # setting init values
    minute_start = 0
    home_score = 0
    away_score = 0
    # Loop over the rows of df_match to perform necessary calculations
    for i, row in df_match.iterrows():
        # Set the minute start
        df_match.at[i, 'minute_start'] = minute_start
        # adjust the minute start every time the game restarts
        df_match.at[i, 'minute_spend'] = row['minute_end'] - minute_start
        minute_start = row['minute_end']
        # Adjusting the goal differences
        df_match.at[i, 'home_score'] = home_score
        df_match.at[i, 'away_score'] = away_score
        df_match.at[i, 'home_gd'] = home_score - away_score
        df_match.at[i, 'away_gd'] = away_score - home_score
        # Updating the match scores
        if row['home_new_score']==1:
          home_score = home_score+1
        if row['away_new_score']==1:
          away_score = away_score+1
    # Append each match dataframe to df_list
    df_list.append(df_match)

# Final Dataframe
gd_map_df = pd.concat(df_list).reset_index(drop=True)

gd_map_df.info()

# Remove all 404s since they are null values and represent when a team has scored no Goal
gd_map = gd_map_df.loc[gd_map_df['minute_end'] != 404].reset_index(drop=True)
# gd_map.head(3)
gd_map.info()

# saving the dataframe
gd_map.to_csv('goal_diff_map_nwfl_23_24.csv')

"""#####**AGGREGATION PER INSTANCE OF GD**"""

# List to hold the dfs per team
home_df = []
away_df = []

for team in list_of_teams:
    # All Games
    team_gd_df = gd_map.loc[(gd_map['home_team']==team) | (gd_map['away_team']==team)].reset_index(drop=True)
    # Home Games
    team_gd_home = team_gd_df.loc[team_gd_df['home_team']==team].reset_index(drop=True)
    # Away Games
    team_gd_away = team_gd_df.loc[team_gd_df['away_team']==team].reset_index(drop=True)

    # Aggregation (Home Games)
    # Per Team Face @Home
    per_team_home = team_gd_home.groupby(['home_team','away_team', 'home_gd'])['minute_spend'].sum().reset_index()
    home_df.append(per_team_home)
    # Aggregation (Away Games)
    # Per Team Face @Away
    per_team_away = team_gd_away.groupby(['away_team','home_team', 'away_gd'])['minute_spend'].sum().reset_index()
    away_df.append(per_team_away)

# Combine All Teams Data Per Match Venue (Home/Away)
# Home Games
all_home = pd.concat(home_df).reset_index(drop=True)
# Away Games
all_away = pd.concat(away_df).reset_index(drop=True)

all_home.info()
all_away.info()

all_home.home_gd.value_counts()

all_away.away_gd.value_counts()

# Remove all gd not in range [-3,-2,-1,0,1,2,3]
all_home = all_home.loc[(all_home['home_gd'] >= -3) & (all_home['home_gd'] <= 3)].reset_index(drop=True)
all_away = all_away.loc[(all_away['away_gd'] >= -3) & (all_away['away_gd'] <= 3)].reset_index(drop=True)

all_home.info()
all_away.info()

df_home = all_home.groupby(['home_team', 'home_gd'])['minute_spend'].sum().reset_index()
df_away = all_away.groupby(['away_team', 'away_gd'])['minute_spend'].sum().reset_index()

# Rename columns in the first df
df_home.rename(columns={'home_team': 'Team', 'home_gd': 'gd', 'minute_spend': 'minute_spend_home'}, inplace=True)
# Rename columns in the second df
df_away.rename(columns={'away_team': 'Team', 'away_gd': 'gd', 'minute_spend': 'minute_spend_away'}, inplace=True)

# gd values of interest
desired_values = [-3,-2,-1,0,1,2,3]

# Iterate over the first df
for team in df_home['Team'].unique():
    gd_values = set(df_home[df_home['Team'] == team]['gd'])

    # Check for missing values in desired_values
    missing_values = set(desired_values) - gd_values

    # Add missing values to df_home
    for value in missing_values:
        df_home = df_home.append({'Team': team, 'gd': value, 'minute_spend_home': 0}, ignore_index=True)

# Iterate over the second df
for team in df_away['Team'].unique():
    gd_values = set(df_away[df_away['Team'] == team]['gd'])

    # Check for missing values in desired_values
    missing_values = set(desired_values) - gd_values

    # Add missing values to df_away
    for value in missing_values:
        df_away = df_away.append({'Team': team, 'gd': value, 'minute_spend_away': 0}, ignore_index=True)

# Merge the modified dfs on Team and gd
merged_df = pd.merge(df_home, df_away, on=['Team', 'gd'])

# Display the merged DataFrame
# print(merged_df)
merged_df.sort_values(by=['Team','gd'], inplace=True)
merged_df['total_minutes'] = merged_df.minute_spend_home + merged_df.minute_spend_away

# View Dataframe
merged_df
# Save the Dataframe
merged_df.to_csv('minutes_played_per_gd_nwfl_mid_23_24_season')

"""#####**PLOT VIZ**

######**WRANGLE ACT**
"""

grp_A_gd = merged_df[merged_df['Team'].isin(GrpA)].reset_index(drop=True)
grp_A_gd

grp_B_gd = merged_df[merged_df['Team'].isin(GrpB)].reset_index(drop=True)
grp_B_gd

# list to hold all dfs
dfA_with_pct = []

df = grp_A_gd
for team in GrpA:
    temp_df = df.loc[df['Team']==team].reset_index(drop=True)
    temp_df['min_pct'] = (((temp_df['total_minutes']) / (temp_df.total_minutes.sum())) *100).round(2)
    # Add df to list
    dfA_with_pct.append(temp_df)

# Combine all Group A teams
gd_pct_grpA = pd.concat(dfA_with_pct, ignore_index=True)

dfB_with_pct = []
df = grp_B_gd

for team in GrpB:
    temp_df = df.loc[df['Team']==team].reset_index(drop=True)
    temp_df['min_pct'] = (((temp_df['total_minutes']) / (temp_df.total_minutes.sum())) *100).round(2)
    # Add df to list
    dfB_with_pct.append(temp_df)

# Combine all Group B teams
gd_pct_grpB = pd.concat(dfB_with_pct, ignore_index=True)

"""######**DATA VIZ TABLE**"""

gd_pct_grpB

gd_pct_grpA

"""## **MORE DATA NEEDED**

###**RELEGATION TREND**
"""

rel_gls_avg = pd.read_csv('/content/drive/MyDrive/NWFL/csv/2018_2021_NWFL_MID_TABLES.csv')
rel_gls_avg

rel_gls_avg['GD'] = rel_gls_avg['GF'] - rel_gls_avg['GA']

older_szn = rel_gls_avg[['Teams','MP','W','D','L','GF','GA','GD','PTS','Group','Season']]
older_szn

# get 2023/24 data
concat_23 = pd.concat([nwfl23_grpA_gw7, nwfl23_grpB_gw7], ignore_index=True)
concat_23['Season'] = df23_season
concat_23

# get 2023/24 data
relegtn_df = pd.concat([older_szn, concat_23], ignore_index=True)
# calculate averages
relegtn_df['GF_Avg'] = round(relegtn_df['GF'] / relegtn_df['MP'], 2)
relegtn_df['GA_Avg'] = round(relegtn_df['GA'] / relegtn_df['MP'], 2)

# view df
relegtn_df

relegtn_df.Season.unique()

# filter df
s_df = relegtn_df.loc[relegtn_df.Season == "2018/19"]
# calc league avg
MP = int(s_df.MP.unique())
# if season_df['GF'].sum() == season_df['GA'].sum():
#   lavg = (season_df['GF'].sum()) / (2 * (MP * (MP-1)/2))
#   print("season: ", season, " | ", lavg)

s_df.head(2)
s_df.GF.sum() == s_df.GA.sum()
s_df.GF.sum()
MP =int(s_df.MP.unique())
print("Matches Played Per Team: ", MP)
print("Num of Teams: ", MP+1)
gp = int(MP * (MP+1)/2)
print("Games Played In Each Group: ", gp)
print("Total Games in Mid Season: ", 2*gp)
avg = (s_df['GF'].sum()) / (2 * (MP * (MP+1)/2))
print("Games Played In Each Group: ", avg.round(2))

# Data
# Teams of Interest
nwfl_relegated_2018_19 = ['Pelican Stars', 'Sure Babes']
nwfl_relegated_2021_22 = ['Pelican Stars', 'Sunshine Queens']
nwfl_relegated_2022_23 = ['Osun Babes', 'Ibom Angels']

# Colors
others = '#B8C5C5'
relegated = '#C8553D'
facecolor = 'white'
alt_color = "#588B8B"

#
# Create a figure and axes with dark background
fig, ax = plt.subplots(ncols=3, nrows=1, figsize=(15, 3))
fig.patch.set_facecolor(facecolor)

i = MP = gp = 0
for season in sorted(relegtn_df.Season.unique()):
    # filter df
    season_df = relegtn_df.loc[relegtn_df.Season == season]
    # calc league avg
    if season_df['GF'].sum() == season_df['GA'].sum():
      # get matches played per team
      MP = int(season_df.MP.unique())
      # print("Matches Played Per Team: ", MP)
      # print("Num of Teams: ", MP+1)
      # calc games played per group
      gp = int(MP * (MP+1)/2)
      # print("Games Played In Each Group: ", gp)
      # total games played
      gplayed = 2*gp
      # print("Total Games in Mid Season: ", 2*gp)
      # calc total goals scored
      gscored = season_df['GF'].sum()
      # print("Goals Scored: ", gscored)
      # league average
      lavg = (gscored / gplayed).round(2)
      print("season: ", season, " | ", lavg.round(2))
    else:
      print('Error In Goals Calculation!!')

    if i < relegtn_df.Season.nunique():
      # setting up plot axes
      ax[i].set_ylim(0.0, max(season_df.GA_Avg + 0.5))
      ax[i].set_xlim(0.0, max(season_df.GF_Avg + 0.5))
      ax[i].set_facecolor(facecolor)
      # Change the color of ticks
      ax[i].tick_params(axis='both', colors=alt_color)
      hide_spines(axes=ax[i], which_spine='all')
      if i > 0:
        ax[i].set_yticks([])
      # Scatter plot
      for j, team in season_df.iterrows():
          x_value = team['GF_Avg']
          y_value = team['GA_Avg']
          # add offset for name text
          offset = 0.18
          # calc team average
          team_avg = f"(GF: {team.GF} , GA: {team.GA})"
          # Decide color
          if season == '2018/19':
            if team.Teams not in nwfl_relegated_2018_19:
              color = others
              text_label = ''
            else:
              color = relegated
              text_label = "{} {}".format(team.Teams, team_avg)
          if season == '2021/22':
            if team.Teams not in nwfl_relegated_2021_22:
              color = others
              text_label = ''
            else:
              color = relegated
              text_label = "{} {}".format(team.Teams, team_avg)
              if team.Teams == "Sunshine Queens":
                offset = -0.18
          if season == '2022/23':
            if team.Teams not in nwfl_relegated_2022_23:
              color = others
              text_label = ''
            else:
              color = relegated
              text_label = "{} {}".format(team.Teams, team_avg)
              if team.Teams == "Ibom Angels":
                offset = -0.18

          # Plot Scatter
          scatter = ax[i].scatter(x_value, y_value, color=color, edgecolor='grey',
                                  alpha=0.7, zorder=4)
          # Add text above each scatter point with a white outline
          ax[i].text(x_value, y_value + offset, text_label,
                  ha='left', va='center', color='black', zorder=5, fontweight='normal',
                  fontsize=10, path_effects=[withStroke(linewidth=0.25, foreground='black')])

      # Showing League Average
      ax[i].vlines(x=lavg, ymin=ax[i].get_ylim()[0], ymax=ax[i].get_ylim()[1], linestyle='--', color='black', alpha=.1, zorder=4)
      ax[i].hlines(y=lavg, xmin=ax[i].get_xlim()[0], xmax=ax[i].get_xlim()[1], linestyle='--', color='black', alpha=.1, zorder=4)
      # Add arrow and text at the point of intersection
      arrow_properties = dict(facecolor='black', edgecolor=alt_color, arrowstyle='->', alpha=.5)
      if i > 0:
        arrow_spine = 2.5
      else:
        arrow_spine = 2.25
      ax[i].annotate('({}) LAvg'.format(lavg),
                  xy=(lavg, lavg), xycoords='data',
                  xytext=(arrow_spine, arrow_spine), textcoords='data',
                  arrowprops=arrow_properties,
                  fontsize=10, color=alt_color,
                  path_effects=[withStroke(linewidth=0.25, foreground='black')])
      # Set title
      ax[i].set_title(f'{(season)}'.upper(), color='black', fontweight='semibold')
      # change axes
      i +=1

plt.savefig("relegation_goals_averages_2018_to_Date.png", dpi=200)
plt.show();

"""### **TEAM RATINGS IN THE NWFL**"""



"""### **SCORING CHANCES (A1,B1,A2,B2,A3+ & B3+) --- USE DATA FROM 2018 TILL DATE**"""





"""### **HOW HARD IS IT TO WIN A GAME IN THE NWFL?**"""



"""### **POINTS WON FROM LOSING POSITIONS**"""



"""### **POINTS DROPPED FROM WINNING POSITIONS**"""



"""### **DASHBOARD**"""



"""### **TEAM RATINGS**"""



"""### **TEAM IN FOCUS: EDO QUEENS**"""



"""### **TEAM IN FOCUS: DELTA QUEENS**"""

